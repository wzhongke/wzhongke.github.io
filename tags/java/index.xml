<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on World of Wang</title>
    <link>https://wzhongke.github.io/tags/java/</link>
    <description>Recent content in java on World of Wang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 23 Feb 2019 12:39:00 +0000</lastBuildDate>
    
	<atom:link href="https://wzhongke.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>java 内存以及GC</title>
      <link>https://wzhongke.github.io/post/java/java%E5%A0%86%E5%86%85%E5%AD%98/</link>
      <pubDate>Sat, 23 Feb 2019 12:39:00 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java%E5%A0%86%E5%86%85%E5%AD%98/</guid>
      <description>java 堆内存 根据 Generation 算法，Java 的堆内存被划分为新生代、老年代和持久代。新生代又进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 FromSpace(Survivor0) 和 ToSpace(Survivo1) 组成。 所有通过 new 创建的对象都</description>
    </item>
    
    <item>
      <title>java 使用代码计算内存</title>
      <link>https://wzhongke.github.io/post/java/java%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98/</link>
      <pubDate>Fri, 22 Feb 2019 11:02:00 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98/</guid>
      <description>原始类型 在java中，原始类型占用的内存大小是固定的： 类型 | 大小 (byte) :&amp;mdash;&amp;mdash;-|:&amp;mdash;&amp;mdash;&amp;mdash; boolean | 1 byte | 1 short | 2 char | 2 int | 4 float | 4 long | 8 double | 8 对象大小计算 对象大小可以</description>
    </item>
    
    <item>
      <title>高并发 netty</title>
      <link>https://wzhongke.github.io/post/java/netty/</link>
      <pubDate>Fri, 20 Jul 2018 18:51:00 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/netty/</guid>
      <description>问题 现在我们使用应用程序或者类库来实现系统之间的通信，比如我们使用一个HTTP客户端从 web 服务器上获取信息，使用 RPC 执行远程方法调用。。 然而有时</description>
    </item>
    
    <item>
      <title>spring 学习笔记</title>
      <link>https://wzhongke.github.io/post/java/springlearn/</link>
      <pubDate>Sun, 21 Jan 2018 16:00:00 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/springlearn/</guid>
      <description>IoC (Inversion of Control), 也叫 DI (Dependency injection)，对象通过构造函数参数，工厂方法参数或者在工厂方法构造或返回的实例上设置属性来定义他们之间的依赖关系，容</description>
    </item>
    
    <item>
      <title>jvm调优</title>
      <link>https://wzhongke.github.io/post/java/jvm%E8%B0%83%E4%BC%98/</link>
      <pubDate>Thu, 21 Sep 2017 12:00:00 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/jvm%E8%B0%83%E4%BC%98/</guid>
      <description>垃圾回收 CMS 收集器无法处理浮动垃圾（Floating Garbage），可能会出现 Concurrent Mode Failure 失败，而导致另一次 STW 的 Full GC 的产生。 由于 CMS 并发清理阶段用户</description>
    </item>
    
    <item>
      <title>单例实现方式</title>
      <link>https://wzhongke.github.io/post/java/%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sun, 30 Jul 2017 11:41:43 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid>
      <description>有时候需要采用延迟初始化来降低初始化类和创建对象的开销。双重检查锁定是常见的延时初始化技术。 基于volatile的单例，双锁检测 该方式中，必</description>
    </item>
    
    <item>
      <title>java中没有见过的用法</title>
      <link>https://wzhongke.github.io/post/java/java%E4%B8%AD%E6%B2%A1%E6%9C%89%E8%A7%81%E8%BF%87%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Thu, 20 Jul 2017 17:16:32 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java%E4%B8%AD%E6%B2%A1%E6%9C%89%E8%A7%81%E8%BF%87%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>interface &amp;amp; interface 在阅读Comparator源码时，无意间发现了如下这种用法： public static &amp;lt;T, U extends Comparable&amp;lt;? super U&amp;gt;&amp;gt; Comparator&amp;lt;T&amp;gt; comparing( Function&amp;lt;? super T, ? extends U&amp;gt; keyExtractor) { Objects.requireNonNull(keyExtractor); return (Comparator&amp;lt;T&amp;gt; &amp;amp; Serializable) (c1, c2) -&amp;gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2)); } 在这个方法中有 (Comparator&amp;lt;T&amp;gt; &amp;amp;</description>
    </item>
    
    <item>
      <title>Lambda表达式和Stream</title>
      <link>https://wzhongke.github.io/post/java/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cstream/</link>
      <pubDate>Thu, 20 Jul 2017 12:14:12 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cstream/</guid>
      <description>流被设计为与lambda表达式一起使用，这使得日常编程更容易。 Lambda 表达式 匿名类的一个非常明显的问题是，如果匿名类的实现非常简单，例如只包含一个</description>
    </item>
    
    <item>
      <title>java线程池技术</title>
      <link>https://wzhongke.github.io/post/java/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Mon, 03 Jul 2017 19:01:11 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF/</guid>
      <description>服务器在处理客户端请求时，经常面对的是客户端的任务简单，单一。如果针对每个任务，都创建一个线程执行，那么对于成千上万的客户端任务，服务器会创</description>
    </item>
    
    <item>
      <title>java 文件处理</title>
      <link>https://wzhongke.github.io/post/java/java-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 30 Jun 2017 11:41:43 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</guid>
      <description>Path Path 是java7中java.nio.file包中的类，它是一个抽象构造。创建和处理Path不会马上绑定到对应的物理位置，如果试图读取一个未创</description>
    </item>
    
    <item>
      <title>java修改字符串编码</title>
      <link>https://wzhongke.github.io/post/java/java%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/</link>
      <pubDate>Sun, 18 Jun 2017 19:01:11 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/</guid>
      <description>使用java处理接口返回数据时，经常会有编码转换的问题。 一开始以为如果将gbk编码的数据转换为utf8的数据，那么应该使用gbk编码获取数据</description>
    </item>
    
    <item>
      <title>java中override与overload的区别</title>
      <link>https://wzhongke.github.io/post/java/java%E4%B8%ADoverride%E4%B8%8Eoverload%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 23 Jul 2015 17:16:32 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java%E4%B8%ADoverride%E4%B8%8Eoverload%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>override（重写，覆盖） 方法名、参数、返回值相同。 子类方法不能缩小父类方法的访问权限。 子类方法不能抛出比父类方法更多的异常(但子类方法</description>
    </item>
    
    <item>
      <title>java中的先赋值再定义</title>
      <link>https://wzhongke.github.io/post/java/java%E4%B8%AD%E7%9A%84%E5%85%88%E8%B5%8B%E5%80%BC%E5%86%8D%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Thu, 02 Apr 2015 11:32:36 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java%E4%B8%AD%E7%9A%84%E5%85%88%E8%B5%8B%E5%80%BC%E5%86%8D%E5%AE%9A%E4%B9%89/</guid>
      <description>如下代码 public class MyTest{ { value = 3; System.out.println(&amp;#34;函数块&amp;#34;); } MyTest(){ System.out.println(&amp;#34</description>
    </item>
    
  </channel>
</rss>