<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on World of Wang</title>
    <link>https://wzhongke.github.io/categories/java/</link>
    <description>Recent content in Java on World of Wang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright@Kevin Tan</copyright>
    <lastBuildDate>Thu, 21 Sep 2017 12:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://wzhongke.github.io/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>jvm调优</title>
      <link>https://wzhongke.github.io/post/java/jvm%E8%B0%83%E4%BC%98/</link>
      <pubDate>Thu, 21 Sep 2017 12:00:00 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/jvm%E8%B0%83%E4%BC%98/</guid>
      <description>在常见的线上问题中，如下问题比较常见： - 内存泄露 - 某个进程CPU突然飙升 - 线程死锁 - 响应变慢 如果遇到上述问题，我们可以基于监控工具来定位问题</description>
    </item>
    
    <item>
      <title>java 泛型</title>
      <link>https://wzhongke.github.io/post/java/java-%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Sun, 17 Sep 2017 19:42:25 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java-%E6%B3%9B%E5%9E%8B/</guid>
      <description>在java中使用泛型，可以避免使用Object或者强制类型转换。泛型最适用于集合类，比如List。 使用泛型编写代码增加了其可复用性，可以被许</description>
    </item>
    
    <item>
      <title>单例实现方式</title>
      <link>https://wzhongke.github.io/post/java/%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sun, 30 Jul 2017 11:41:43 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid>
      <description>有时候需要采用延迟初始化来降低初始化类和创建对象的开销。双重检查锁定是常见的延时初始化技术。 基于volatile的单例，双锁检测 该方式中，必</description>
    </item>
    
    <item>
      <title>java中没有见过的用法</title>
      <link>https://wzhongke.github.io/post/java/java%E4%B8%AD%E6%B2%A1%E6%9C%89%E8%A7%81%E8%BF%87%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Thu, 20 Jul 2017 17:16:32 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java%E4%B8%AD%E6%B2%A1%E6%9C%89%E8%A7%81%E8%BF%87%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>interface &amp;amp; interface 在阅读Comparator源码时，无意间发现了如下这种用法： public static &amp;lt;T, U extends Comparable&amp;lt;? super U&amp;gt;&amp;gt; Comparator&amp;lt;T&amp;gt; comparing( Function&amp;lt;? super T, ? extends U&amp;gt; keyExtractor) { Objects.requireNonNull(keyExtractor); return (Comparator&amp;lt;T&amp;gt; &amp;amp; Serializable) (c1, c2) -&amp;gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2)); } 在这个方法中有 (Comparator&amp;lt;T&amp;gt; &amp;amp;</description>
    </item>
    
    <item>
      <title>Lambda表达式和Stream</title>
      <link>https://wzhongke.github.io/post/java/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cstream/</link>
      <pubDate>Thu, 20 Jul 2017 12:14:12 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cstream/</guid>
      <description>流被设计为与lambda表达式一起使用，这使得日常编程更容易。 Lambda 表达式 匿名类的一个非常明显的问题是，如果匿名类的实现非常简单，例如只包含一个</description>
    </item>
    
    <item>
      <title>java线程池技术</title>
      <link>https://wzhongke.github.io/post/java/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Mon, 03 Jul 2017 19:01:11 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF/</guid>
      <description>服务器在处理客户端请求时，经常面对的是客户端的任务简单，单一。如果针对每个任务，都创建一个线程执行，那么对于成千上万的客户端任务，服务器会创</description>
    </item>
    
    <item>
      <title>java 文件处理</title>
      <link>https://wzhongke.github.io/post/java/java-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 30 Jun 2017 11:41:43 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</guid>
      <description>Path Path 是java7中java.nio.file包中的类，它是一个抽象构造。创建和处理Path不会马上绑定到对应的物理位置，如果试图读取一个未创</description>
    </item>
    
    <item>
      <title>java修改字符串编码</title>
      <link>https://wzhongke.github.io/post/java/java%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/</link>
      <pubDate>Sun, 18 Jun 2017 19:01:11 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/</guid>
      <description>使用java处理接口返回数据时，经常会有编码转换的问题。 一开始以为如果将gbk编码的数据转换为utf8的数据，那么应该使用gbk编码获取数据</description>
    </item>
    
    <item>
      <title>java中override与overload的区别</title>
      <link>https://wzhongke.github.io/post/java/java%E4%B8%ADoverride%E4%B8%8Eoverload%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 23 Jul 2015 17:16:32 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java%E4%B8%ADoverride%E4%B8%8Eoverload%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>override（重写，覆盖） 方法名、参数、返回值相同。 子类方法不能缩小父类方法的访问权限。 子类方法不能抛出比父类方法更多的异常(但子类方法</description>
    </item>
    
    <item>
      <title>java中的先赋值再定义</title>
      <link>https://wzhongke.github.io/post/java/java%E4%B8%AD%E7%9A%84%E5%85%88%E8%B5%8B%E5%80%BC%E5%86%8D%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Thu, 02 Apr 2015 11:32:36 +0000</pubDate>
      
      <guid>https://wzhongke.github.io/post/java/java%E4%B8%AD%E7%9A%84%E5%85%88%E8%B5%8B%E5%80%BC%E5%86%8D%E5%AE%9A%E4%B9%89/</guid>
      <description>如下代码 public class MyTest{ { value = 3; System.out.println(&amp;quot;函数块&amp;quot;); } MyTest(){ System.out.println(&amp;q</description>
    </item>
    
  </channel>
</rss>