---
title: 设计模式
---

曾经多少次有过这种感觉：你已经解决过一个问题但就是不能确切知道不在什么地方或怎么解决的，如果你能记起以前问题的细节和怎么解决的，你就可以利用之前的经验而不需要重新发现它。所以我们需要将解决问题的经验记录下来。
设计模式使人们可以更加简单地复用成功的设计和体系结构。每个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。
一个模式有四个基本要素：
1. 模式名称: 一个助记名，有一两个词来描述模式的问题、解决方案和效果；
2. 问题： 描述了应该在何时使用何种模式；
3. 解决方案： 描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式；
4. 效果： 描述了模式应用的效果及使用模式应权衡的问题

## 设计模式在编目

根据模式的目的，可以将模式分为：创建型（与对象的创建有关）、结构型（处理类或对象的组合）、行为型（对类或对象怎样交互和怎样分配职责进行描述）
根据模式的范围，可以将模式分为：类（处理类和子类之间的关系，这些关系通过继承建立，是静态的）、对象（处理对象间的关系，这些关系在运行时刻是变化的，是动态的）

### 创建型模式
随着系统演化越来越依赖于对象复合而不是类继承，创建型模式变得更为重要。创建型模式有两个重要作用：将系统使用哪些具体的类的信息封装起来；隐藏了这些类的实例是如何被创建和放在一起的。**整个系统对于这些对象所知道的是由抽象类所定义的接口**

名称  | 目的 | 范围 | 描述 
:-----|:----|:----|:----
Abstract Factory (抽象工厂)| 创建型 | 对象 | 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
Factory Method| 创建型 | 类| 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method将一个类的实例化延迟到子类中
Singleton | 创建型 | 对象 | 保证一个类只有一个实例，并提供一个访问它的全局访问点
Prototype| 创建型 | 对象 | 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象
Adapter (适配器)        | 结构型 | 类 |  将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
Bridge (桥接模式)       | 结构型 | 对象| 将抽象部分与它的实现部分分离，使它们都可以独立地变化
Builder ()            | 结构型 | 对象 |将一个复杂对象构建与它的表示分离，使得同样的构建过程可以创建不同的表示
Composite            | 结构型 | 对象|将对象组合成树形以表示“部分-整体”的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性
Decorator           | 结构型 | 对象 | 动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活
Facade        | 结构型 | 对象 | 为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
Flyweight   | 结构型 | 对象 | 运用共享技术有效地支持大量细粒度的对象
Interpreter | 行为型 | 类| 给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语句中的句子
Iterator    | 行为型 | 对象 | 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示
Mediator  | 行为型 | 对象 | 用一个中介对象来封装一系列的对象交互，中介者使各个对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
Memento   | 行为型 | 对象 | 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态
Observer  | 行为型 | 对象 | 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖他的对象都得到通知并自动刷新
Proxy     | 结构型 | 对象 | 为其他对象提供一个代理以控制对这个对象的访问
State     | 行为型 | 对象 | 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它所属的类
Strategy  | 行为型 | 对象 | 定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。本模式使算法的变化可独立于使用它的用户
Template Method | 行为型 | 类 | 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。本模式使得子类可以不改变一个算法的结构就可以重新定义该算法的某些特定的步骤
Visitor | 行为型 | 对象 | 表示一个作用于某对象结构中的各元素的操作。可以在不改变各元素的类的前提下定义作用于这些元素的新操作
Chain of Responsibility  | 行为型| 对象 | 为解除请求的发送者和接受者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它
Command (命令模式)    |  行为型| 对象 | 将请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作

### 对象
面向对象设计最困难的部分是将系统分解成对象集合。因为要考虑许多因素：封装、粒度、依赖关系、灵活性、性能、演化、复用等等，他们都影响着系统的分解，并且这些因素通常还是相互冲突的。
面向对象设计方法学支持许多设计方法。可以写出一个问题描述，挑出名词和动词，进而创建相应的类和方法；或者可以关注于系统的写作和职责关系；或者可以对现实世界建模，再将分析时发现的对象转化至设计中。

**对象的类**定义了对象是怎样实现的，同时也定义了独享的内部状态和操作的实现；
**对象的类型**只与它的接口有关，接口即对象能响应的请求的集合。
当我们说一个对象是一个类的实例的时候，指的是该对象支持类所定义的接口。
类继承根据一个对象的实现定义了另一个对象的实现；接口继承描述了一个对象什么时候能被用来替代另一个对象。

面向对象编程中，一个比较重要的法则就是：**对接口编程，而不是对实现编程**。具体含义就是不讲变量声明为某个特定的具体类的实例对象，而是让它遵从抽象类所定义的接口。创建型模式就是确保系统时采用针对接口编写的，而不是针对实现编写的。

### 类继承 和 对象组合
对象组合是类继承之外的另一种复用选择，新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。
类继承是在编译时刻静态定义的，且可直接使用，因为程序设计语言直接支持类继承。当一个子类重定义一些而不是全部操作时，它也能影响它所继承的操作，只要在这些操作中调用了被重定义的操作。
对象组合是通过获得对其他对象的引用而在运行时刻动态定义的。组合要求对象遵循彼此的接口约定，进而要求更仔细地定义接口。因为对象只能通过接口访问，所以我们并不破坏封装性；只要类型一致，运行时刻还可以用一个对象来代替另一个对象；而且因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系。
对象组合在设计上还有另外一个作用：即优先使用对象组合有助于你保持每个类被封装，并被集中在单个任务上。这样 类和继承 层次会保持较小规模，并且不大可能增长为不可控的庞然大物。而且给予对象组合的设计会有更多的对象，较少的类，且系统的行为将依赖于对象间的关系而不是被定义在某个类中。
对象设计的另一个原则： **优先使用对象组合，而不是类继承**

## 委托
**委托是一种组合方法，它使组合具有与继承同样的复用能力**。在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给它的代理者。
委托的主要优点在于它便于运行时刻组合独享操作以及改变这些操作的组合方式。其主要缺点是 动态的、高度参数化的软件比静态软件更难以理解。

## 参数化类型 -- Java中的泛型
参数化类型给我们提供除了类继承和对象组合外的第三种方法来组合对象的行为。

