<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>Lambda表达式和Stream | 壹叶知秋的博客 | 不要为恐惧所驾驭...</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="java">
    <meta name="description" content="流被设计为与lambda表达式一起使用，这使得日常编程更容易。 Lambda 表达式匿名类的一个非常明显的问题是，如果匿名类的实现非常简单，例如只包含一个方法的接口，那么匿名类的语法可能看起来很笨重而且也不清晰。在这些情况下，可以将功能作为参数传递给另一种方法。Lambda表达式就是为此而生，它能够将功能视为方法参数或将代码作为数据。对于单一方法的实例，相对于匿名类，lambda表达式可以更紧凑地">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Lambda表达式和Stream">
<meta property="og:url" content="http://wzhongke.github.io/2017/07/20/Lambda表达式和Stream/index.html">
<meta property="og:site_name" content="壹叶知秋的博客">
<meta property="og:description" content="流被设计为与lambda表达式一起使用，这使得日常编程更容易。 Lambda 表达式匿名类的一个非常明显的问题是，如果匿名类的实现非常简单，例如只包含一个方法的接口，那么匿名类的语法可能看起来很笨重而且也不清晰。在这些情况下，可以将功能作为参数传递给另一种方法。Lambda表达式就是为此而生，它能够将功能视为方法参数或将代码作为数据。对于单一方法的实例，相对于匿名类，lambda表达式可以更紧凑地">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-08-21T11:32:12.791Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lambda表达式和Stream">
<meta name="twitter:description" content="流被设计为与lambda表达式一起使用，这使得日常编程更容易。 Lambda 表达式匿名类的一个非常明显的问题是，如果匿名类的实现非常简单，例如只包含一个方法的接口，那么匿名类的语法可能看起来很笨重而且也不清晰。在这些情况下，可以将功能作为参数传递给另一种方法。Lambda表达式就是为此而生，它能够将功能视为方法参数或将代码作为数据。对于单一方法的实例，相对于匿名类，lambda表达式可以更紧凑地">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-9350854994277981",
            enable_page_level_ads: true
        });
    </script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-105841950-1', 'auto');
        ga('send', 'pageview');

    </script>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/sign.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">壹叶知秋</h5>
          <a href="mailto:993287653@qq.com" title="993287653@qq.com" class="mail">993287653@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wzhongke" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Lambda表达式和Stream</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Lambda表达式和Stream</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-07-20T12:14:12.000Z" itemprop="datePublished" class="page-time">
  2017-07-20
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/java/">java</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Lambda-表达式"><span class="post-toc-number">1.</span> <span class="post-toc-text">Lambda 表达式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#使用Lambda表达式的理想情况"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">使用Lambda表达式的理想情况</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-创建搜索符合某个特征成员的方法"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">1. 创建搜索符合某个特征成员的方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-创建一个更通用的搜索方法"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">2. 创建一个更通用的搜索方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-在Local-Class中指定搜索情况的代码"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">3. 在Local Class中指定搜索情况的代码</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-使用匿名类"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">4. 使用匿名类</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-使用Lambda表达式"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">5. 使用Lambda表达式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-使用标准的函数式接口"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">6. 使用标准的函数式接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-在应用中使用Lambda表达式"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">7. 在应用中使用Lambda表达式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-使用泛型"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">8. 使用泛型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-使用接受Lambda表达式作为参数的聚合操作"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">9. 使用接受Lambda表达式作为参数的聚合操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#接口-–-默认方法"><span class="post-toc-number">2.</span> <span class="post-toc-text">接口 – 默认方法</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#函数式接口"><span class="post-toc-number">3.</span> <span class="post-toc-text">函数式接口</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#方法引用"><span class="post-toc-number">4.</span> <span class="post-toc-text">方法引用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#方法应用的类型"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">方法应用的类型</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#聚合操作"><span class="post-toc-number">5.</span> <span class="post-toc-text">聚合操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Stream-reduce-方法"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">Stream.reduce 方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Stream-collect-方法"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">Stream.collect 方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#并行处理流"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">并行处理流</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#并行归纳"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">并行归纳</span></a></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-Lambda表达式和Stream"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Lambda表达式和Stream</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-07-20 12:14:12" datetime="2017-07-20T12:14:12.000Z"  itemprop="datePublished">2017-07-20</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/java/">java</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>流被设计为与lambda表达式一起使用，这使得日常编程更容易。</p>
<h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>匿名类的一个非常明显的问题是，如果匿名类的实现非常简单，例如只包含一个方法的接口，那么匿名类的语法可能看起来很笨重而且也不清晰。在这些情况下，可以将功能作为参数传递给另一种方法。Lambda表达式就是为此而生，它能够将功能视为方法参数或将代码作为数据。<br>对于单一方法的实例，相对于匿名类，lambda表达式可以更紧凑地表示。<br><a id="more"></a></p>
<h2 id="使用Lambda表达式的理想情况"><a href="#使用Lambda表达式的理想情况" class="headerlink" title="使用Lambda表达式的理想情况"></a>使用Lambda表达式的理想情况</h2><p>假设要创建一个社交网络应用程序，想要创建一个功能，使管理员可以在符合特定条件的社交网络应用程序的成员上执行任何类型的操作（例如发送消息）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Sex &#123;</div><div class="line">        MALE, FEMALE</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">    String name;</div><div class="line">    LocalDate birthday;</div><div class="line">    Sex gender;</div><div class="line">    String emailAddress;</div><div class="line">    <span class="comment">// getter和setter方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="1-创建搜索符合某个特征成员的方法"><a href="#1-创建搜索符合某个特征成员的方法" class="headerlink" title="1. 创建搜索符合某个特征成员的方法"></a>1. 创建搜索符合某个特征成员的方法</h2><p>最简单的方式是创建几个方法，每个方法都负责搜索出满足某个特性的成员，比如性别或者年龄。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersonOlderThan</span><span class="params">(List&lt;Person&gt; roster, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Person p: roster) &#123;</div><div class="line">        <span class="keyword">if</span> (p.getAge() &gt;= age)</div><div class="line">            p.printPerson();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的方法可能使得应用程序变得脆弱，因为修改Person类，比如修改数据类型，就会导致程序无法正常工作。假设要升级程序，需要改变<code>Person</code>类的结构，增加了新的属性，也许还会改变衡量ages的数据类型或者算法。就需要根据这些修改重写API。</p>
<h2 id="2-创建一个更通用的搜索方法"><a href="#2-创建一个更通用的搜索方法" class="headerlink" title="2. 创建一个更通用的搜索方法"></a>2. 创建一个更通用的搜索方法</h2><p>下面的方法更为通用，它打印了指定年龄段的成员<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersonsWithinAgeRange</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</div><div class="line">        <span class="keyword">if</span> (low &lt;= p.getAge() &amp;&amp; p.getAge() &lt; high) &#123;</div><div class="line">            p.printPerson();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果想要打印指定性别的成员或者指定性别和特定年龄段的成员该怎么办？如果要改变<code>Person</code>类，比如添加一些关系状态或者地理位置的属性，要怎么修改？虽然这个方法比<code>printPersonOlderThan</code>更为通用，但是为不同可能的搜索请求，创建不同的方法，依然会使得代码脆弱。可以将指定要在其他类中搜索的条件的代码分开。</p>
<h2 id="3-在Local-Class中指定搜索情况的代码"><a href="#3-在Local-Class中指定搜索情况的代码" class="headerlink" title="3. 在Local Class中指定搜索情况的代码"></a>3. 在Local Class中指定搜索情况的代码</h2><p>下面的方法可以允许你指定搜索环境。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersons</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster, CheckPerson tester)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</div><div class="line">        <span class="keyword">if</span> (tester.test(p)) &#123;</div><div class="line">            p.printPerson();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的方法使用了<code>CheckPerson</code>的方法<code>test</code>检测了<code>roster</code>中每个<code>Person</code>实例，如果方法返回<code>true</code>，那么<code>printPerson</code>会被调用。<br>可以通过实现<code>CheckPerson</code>接口来指定搜索条件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CheckPerson</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面的类实现了<code>CheckPerson</code>接口，它的<code>test</code>方法过滤了年龄在18到25之间的男性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckPersonEligible</span> <span class="keyword">implements</span> <span class="title">CheckPerson</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> p.gender == Person.Sex.MALE &amp;&amp;</div><div class="line">                p.getAge() &gt;= <span class="number">18</span> &amp;&amp;</div><div class="line">                p.getAge() &lt;= <span class="number">25</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以通过新建一个该类的实例，传递给<code>printPersons</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printPersons(roster, <span class="keyword">new</span> CheckPersonEligible());</div></pre></td></tr></table></figure></p>
<p>虽然这个方式不那么脆弱，如果改变了<code>Person</code>的结构，就不必重新方法了，但是还是要有额外的代码：一个新的接口和新的搜索结果的类。因为<code>CheckPersonEligible</code>实现了接口，可以用一个匿名类代替这个类，这样可以不用为每次搜索都声明一个新类。</p>
<h2 id="4-使用匿名类"><a href="#4-使用匿名类" class="headerlink" title="4. 使用匿名类"></a>4. 使用匿名类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">printPersons(</div><div class="line">    roster,</div><div class="line">    <span class="keyword">new</span> CheckPerson() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> p.getGender() == Person.Sex.MALE</div><div class="line">                &amp;&amp; p.getAge() &gt;= <span class="number">18</span></div><div class="line">                &amp;&amp; p.getAge() &lt;= <span class="number">25</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这种方法减少了所需的代码量，不用每次执行时都创建一个新类。然而，匿名类的语法庞大。因为<code>CheckPerson</code>接口只包含一种方法。在这种情况下，可以使用lambda表达式而不是匿名类。</p>
<h2 id="5-使用Lambda表达式"><a href="#5-使用Lambda表达式" class="headerlink" title="5. 使用Lambda表达式"></a>5. 使用Lambda表达式</h2><p><code>CheckPerson</code>接口是一个函数式接口（functional interface)。函数式接口只包含一个抽象方法。函数式接口可以包含多个<code>default methods</code>和<code>static methods</code>。因为函数式接口只包含一个抽象方法，可以在实现该方法时省略该方法的名称。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">printPersons(</div><div class="line">    roster,</div><div class="line">    (Person p) -&gt; p.getGender() == Person.Sex.MALE</div><div class="line">        &amp;&amp; p.getAge() &gt;= <span class="number">18</span></div><div class="line">        &amp;&amp; p.getAge() &lt;= <span class="number">25</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<h2 id="6-使用标准的函数式接口"><a href="#6-使用标准的函数式接口" class="headerlink" title="6. 使用标准的函数式接口"></a>6. 使用标准的函数式接口</h2><p><code>CheckPerson</code>是一个简单的函数式接口。该方法如此简单，没有必要在程序声明一次。因此，JDK中定义了几个标准的功能接口，可以在<code>java.util.function</code>包中找到它们。<br>可以使用<code>Predicate&lt;T&gt;</code>接口替换<code>CheckPerson</code>，这个接口有一个方法<code>boolean test(T t)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用<code>Predicate&lt;T&gt;</code>接口替换<code>CheckPerson</code>，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">printPersonsWithPredicate(</div><div class="line">    roster,</div><div class="line">    p -&gt; p.getGender() == Person.Sex.MALE</div><div class="line">        &amp;&amp; p.getAge() &gt;= <span class="number">18</span></div><div class="line">        &amp;&amp; p.getAge() &lt;= <span class="number">25</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>不止有这一种方式使用lambda表达式，下面的方式是推荐的方式</p>
<h2 id="7-在应用中使用Lambda表达式"><a href="#7-在应用中使用Lambda表达式" class="headerlink" title="7. 在应用中使用Lambda表达式"></a>7. 在应用中使用Lambda表达式</h2><p>只有实现一个函数式接口，才能使用lambda表达式。<br>如果想要使用另一个lambda表达式，该表达式接收一个参数，并且返回<code>void</code>，可以使用<code>Consumer&lt;T&gt;</code>接口，该接口有一个抽象方法<code>void accept(T t)</code>.<br>我们可以如下定义<code>Person</code>的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static void processPersons(List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester, Consumer&lt;Person&gt; block) &#123;</div><div class="line">    for (Person p: roster) &#123;</div><div class="line">        if (tester.test(p)) &#123;</div><div class="line">            block.accept(p  );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法可以用如下方式调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">processPersons(roster, p -&gt; p.getAge() &gt;= 18, p -&gt; p.printPerson());</div></pre></td></tr></table></figure></p>
<p>如果你不止打印符合条件的信息，比如想要验证成员的信息或者获取他们的联系方式。需要一个有返回值的抽象方法的函数式接口。<code>Function&lt;T,R&gt;</code>包含一个方法<code>R apply(T t)</code>，下面的例子展示了通过<code>mapper</code>获取数据，并使用<code>block</code>处理数据的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void processPersonsWithFunction(List&lt;Person&gt; roster,</div><div class="line">          Predicate&lt;Person&gt; tester,</div><div class="line">          Function&lt;Person, String&gt; mapper,</div><div class="line">          Consumer&lt;String&gt; block) &#123;</div><div class="line">    for (Person p: roster) &#123;</div><div class="line">        if (tester.test(p)) &#123;</div><div class="line">            String data = mapper.apply(p);</div><div class="line">            block.accept(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法可以用如下方式调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">processPersonsWithFunction(</div><div class="line">    roster,</div><div class="line">    p -&gt; p.getGender() == Person.Sex.MALE</div><div class="line">        &amp;&amp; p.getAge() &gt;= 18</div><div class="line">        &amp;&amp; p.getAge() &lt;= 25,</div><div class="line">    p -&gt; p.getEmailAddress(),</div><div class="line">    email -&gt; System.out.println(email)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h2 id="8-使用泛型"><a href="#8-使用泛型" class="headerlink" title="8. 使用泛型"></a>8. 使用泛型</h2><p>下面使用泛型的方法，可以接收任意数据类型的集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static &lt;X, Y&gt; void processElements (</div><div class="line">        Iterable&lt;X&gt; source,</div><div class="line">        Predicate&lt;X&gt; tester,</div><div class="line">        Function&lt;X, Y&gt; mapper,</div><div class="line">        Consumer&lt;Y&gt; block ) &#123;</div><div class="line">    for (X p: source) &#123;</div><div class="line">        if (tester.test(p)) &#123;</div><div class="line">            Y data = mapper.apply(p);</div><div class="line">            block.accept(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的方法可以使用如下方式调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">processElements(</div><div class="line">        roster,</div><div class="line">        p -&gt;  p.getAge() &gt;= 18</div><div class="line">                &amp;&amp; p.getAge() &lt;= 25,</div><div class="line">        p -&gt; p.getEmailAddress(),</div><div class="line">        email -&gt; System.out.println(email)</div><div class="line">        );</div></pre></td></tr></table></figure></p>
<h2 id="9-使用接受Lambda表达式作为参数的聚合操作"><a href="#9-使用接受Lambda表达式作为参数的聚合操作" class="headerlink" title="9. 使用接受Lambda表达式作为参数的聚合操作"></a>9. 使用接受Lambda表达式作为参数的聚合操作</h2><p>下面的例子使用聚合操作来打印email<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">roster.stream().</div><div class="line">    filter( p -&gt;  p.getAge() &gt;= 18</div><div class="line">                &amp;&amp; p.getAge() &lt;= 25)</div><div class="line">    .map(p -&gt; p.getEmailAddress())</div><div class="line">    .forEach( email -&gt; System.out.println(email));</div></pre></td></tr></table></figure></p>
<h1 id="接口-–-默认方法"><a href="#接口-–-默认方法" class="headerlink" title="接口 – 默认方法"></a>接口 – 默认方法</h1><p>java8中在接口中可以定义默认方法，默认方法同抽象类中的非抽象方法类似，子类可以选择是否覆盖。<br>这样就可以在接口中添加新的方法，而不用修改原有实现该接口的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface DefaultInterface &#123;</div><div class="line">    default String defaultMethod() &#123;</div><div class="line">        return &quot;Default method&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口的默认方法可以不用加<code>public</code>前缀，因为接口中的方法都是<code>public</code>的。<br>还可以定义静态的方法，和类中的静态方法相同，都是与类相关联的，而不是它的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface DefaultInterface &#123;</div><div class="line">    static String defaultMethod() &#123;</div><div class="line">        return &quot;Static method&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认方法可以向现有接口中添加支持lambda表达式作为参数的方法。</p>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p><code>@FunctionalInterface</code>注解的接口是函数式接口。使用此种接口作为函数参数的方法，传递参数时，可以使用lambda表达式作为参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void sort(Comparator&lt;Card&gt; c) &#123;</div><div class="line">   Collections.sort(entireDeck, c);</div><div class="line">&#125;</div><div class="line">// 可以这样调用</div><div class="line">deck.sort((firstCart, secondCard) -&gt; firstCart.getRank().value() - secondCard.getRank().value());</div></pre></td></tr></table></figure></p>
<p>如果只是创建一个Comparator实例来比较可以从诸如getValue或hashCode之类的方法返回数值的任何对象，我们可以使用<code>Comparator</code>接口提供的静态方法<code>comparing</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">deck.sort(Comparator.comparing((card) -&gt; card.getRank())); </div><div class="line">// 还可以写成方法引用</div><div class="line">deck.sort(Comparator.comparing(Card::getRank));</div></pre></td></tr></table></figure></p>
<p><code>Comparator</code>还提供了<code>comparingDouble</code>、<code>thenComparing</code>等一系列方法来创建<code>Comparator</code>实例。<br>如果要创建一个可以将对象的多个属性进行比较的Comparator实例，如下例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">deck.sort(</div><div class="line">    (firstCard, secondCard) -&gt; &#123;</div><div class="line">        int compare =</div><div class="line">            firstCard.getRank().value() - secondCard.getRank().value();</div><div class="line">        if (compare != 0)</div><div class="line">            return compare;</div><div class="line">        else</div><div class="line">            return firstCard.getSuit().value() - secondCard.getSuit().value();</div><div class="line">    &#125;      </div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>我们可以使用<code>Comparator</code>接口提供的静态方法来创建实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deck.sort(</div><div class="line">    Comparator</div><div class="line">        .comparing(Card::getRank)</div><div class="line">        .thenComparing(Comparator.comparing(Card::getSuit)));</div></pre></td></tr></table></figure></p>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>我们使用lambda表达式来创建匿名方法。但是，有时候使用lambda表达式只是调用了一个方法。这种情况下，通过方法引用现有方法往往更加清晰。使用方法引用，可以使代码更紧凑，更易于阅读。<br>如果对<code>Person</code>的数组根据<code>age</code>属性进行排序。或许可以使用下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class PersonAgeComparator implements Comparator&lt;Person&gt; &#123;</div><div class="line">    public int compare(Person a, Person b) &#123;</div><div class="line">        return a.getBirthday().compareTo(b.getBirthday());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Person[] rosterAsArray = roster.toArray(new Person[roster.size()]);</div><div class="line">Arrays.sort(rosterAsArray, new PersonAgeComparator());</div></pre></td></tr></table></figure></p>
<p><code>sort</code>方法的签名是<code>static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)</code>。<code>Comparator</code>接口是函数式接口，所以我们可以使用lambda表达式代替<code>PersonAgeComparator</code>类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Arrays.sort(rosterAsArray,</div><div class="line">        (Person a, Person b) -&gt; a.getBirthday().compareTo(b.getBirthday())</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>我们还可以定义<code>Person</code>的静态方法<code>compareByAge</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static int compareByAge(Person a, Person b) &#123;</div><div class="line">    return a.birthday.compareTo(b.birthday);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么上边的方法可以写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Arrays.sort(rosterAsArray,</div><div class="line">    (a, b) -&gt; Person.compareByAge(a, b)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>因为lambda表达式调用了一个已经存在的方法，我们可以用方法引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Arrays.sort(rosterAsArray, Person::compareByAge);</div></pre></td></tr></table></figure></p>
<p>使用方法引用由两个条件：</p>
<ol>
<li>其形式参数列表从<code>Comparator &lt;Person&gt; .compare</code>复制，是<code>(Person，Person)</code>。也就是说方法引用的方法的参数类型需要同所需要的参数类型是一致的。</li>
<li>它的调用时<code>Person.compareByAge</code><h2 id="方法应用的类型"><a href="#方法应用的类型" class="headerlink" title="方法应用的类型"></a>方法应用的类型</h2>| 类型   | 示例<br>:——–|:———–<br>|应用静态方法| ContainingClass::staticMethodName<br>|某个对象的方法| containingObject::instanceMethodName<br>|引用特定类型的任意对象的实例方法|ContainingType::methodName<br>|构造器方法|ClassName::new<br>主要介绍下构造器方法：<br>同静态方法引用类似，我们可以用<code>new</code>来使用构造器引用。以下方法将元素从一个集合复制到另一个集合：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static &lt;T, SOURCE extends Collection&lt;T&gt;, DEST extends Collection&lt;T&gt;&gt;</div><div class="line">    DEST transferElements(</div><div class="line">        SOURCE sourceCollection,</div><div class="line">        Supplier&lt;DEST&gt; collectionFactory) &#123;</div><div class="line">        </div><div class="line">        DEST result = collectionFactory.get();</div><div class="line">        for (T t : sourceCollection) &#123;</div><div class="line">            result.add(t);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>函数式接口<code>Supplier</code>包含一个方法，其签名为<code>T get()</code>。可以通过如下方式调用该方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Set&lt;Person&gt; rosterSetLambda =</div><div class="line">    transferElements(roster, () -&gt; &#123; return new HashSet&lt;&gt;(); &#125;);</div><div class="line">Set&lt;Person&gt; rosterSet = transferElements(roster, HashSet::new);</div></pre></td></tr></table></figure></p>
<h1 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h1><p>聚合操作描述了以下管道的操作，它计算了集合<code>roster</code>中所有男性的平均年龄：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">double average = roster</div><div class="line">    .stream()</div><div class="line">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</div><div class="line">    .mapToInt(Person::getAge)</div><div class="line">    .average()</div><div class="line">    .getAsDouble();</div></pre></td></tr></table></figure></p>
<p>JDK中包含许多终止操作（如：<code>average</code>, <code>sum</code>, <code>min</code>, <code>max</code> 和 <code>count</code>），终止操作返回一个对流中数据计算的值。这些操作被称为归纳操作，也有些归纳操作返回一个集合。许多归纳操作执行像计算平局值或者将元素分类的操作。主要有两个方法： <code>Stream.reduce</code>类方法；<code>Stream.collect</code>类方法</p>
<h2 id="Stream-reduce-方法"><a href="#Stream-reduce-方法" class="headerlink" title="Stream.reduce 方法"></a>Stream.reduce 方法</h2><p>Stream.reduce方法是通用的简化操作，比如下例中的<code>Stream.sum</code>归纳操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Integer totlaAge = roster</div><div class="line">    .stream()</div><div class="line">    .mapToInt(Person::getAge)</div><div class="line">    .sum();</div></pre></td></tr></table></figure></p>
<p>使用<code>Stream.reduce</code>操作也能实现上述操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Integer totalAgeReduce = roster</div><div class="line">   .stream()</div><div class="line">   .map(Person::getAge)</div><div class="line">   .reduce(</div><div class="line">       0,</div><div class="line">       (a, b) -&gt; a + b);</div></pre></td></tr></table></figure></p>
<p><code>reduce</code>操作需要两个参数：</p>
<ul>
<li><code>identity</code>: 该参数是归纳操作的初始值，如果集合中没有元素，也是默认的返回值。</li>
<li><code>accumulator</code>: 累加器函数需要两个参数：归纳的一部分结果和流的下一个元素。它返回一个新的部分结果。<h2 id="Stream-collect-方法"><a href="#Stream-collect-方法" class="headerlink" title="Stream.collect 方法"></a>Stream.collect 方法</h2><code>collect</code>方法会改变现有值。<br>如果要计算一个stream中的平均值，需要两段数据：stream中的元素的总数和元素的和。与<code>reduce</code>类似，<code>collect</code>方法也只返回一个值。可以创建一个新的数据类型，跟踪元素的总数和这些元素的和：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Averager implements IntConsumer</div><div class="line">&#123;</div><div class="line">    private int total = 0;</div><div class="line">    private int count = 0;</div><div class="line">        </div><div class="line">    public double average() &#123;</div><div class="line">        return count &gt; 0 ? ((double) total)/count : 0;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    public void accept(int i) &#123; total += i; count++; &#125;</div><div class="line">    public void combine(Averager other) &#123;</div><div class="line">        total += other.total;</div><div class="line">        count += other.count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>下面的管道使用了<code>Average</code>类和<code>collect</code>方法来计算男性成员的平均年龄：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Averager averageCollect = roster.stream()</div><div class="line">        .filter(p -&gt; p.getGender() == Person.Sex.MALE)</div><div class="line">        .map(Person::getAge)</div><div class="line">        .collect(Averager::new, Averager::accept, Averager::combine);</div><div class="line">System.out.println(&quot;Average age of male members: &quot; + averageCollect.average());</div></pre></td></tr></table></figure></p>
<p><code>collect</code>方法需要三个参数：</p>
<ul>
<li><code>supplier</code>: 该参数需要一个工厂方法，它创建了新的实例。对于<code>collect</code>操作来说，它创建了放置结果的容器，就如<code>Averager</code></li>
<li><code>accumulator</code>: 累加器功能将流元素结合到结果容器。在此示例中，它通过将count变量增加1来修改Averager结果容器，并将总成员变量添加到流元素的值，该元素是表示男性成员年龄的总和。</li>
<li><code>combiner</code>: 组合器功能需要两个结果容器并合并其内容。<br>虽然JDK为您提供了平均运算以计算流中元素的平均值，但如果需要从流的元素中计算多个值，则可以使用<code>collect</code>操作和自定义类。<br><code>collect</code>操作非常适合于集合。以下示例将男性成员的名字提取出来：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; namesOfMaleMembersCollect = roster</div><div class="line">    .stream()</div><div class="line">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</div><div class="line">    .map(Person::getName)</div><div class="line">    .collect(Collectors.toList());</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上述例子中，<code>collect</code>操作需要一个<code>Collector</code>类型的参数。该类中封装了<code>collect</code>所需要的三个参数。<br><code>Collectors</code>类中包含了许多有用的归纳操作，例如将元素累积到集合中并根据各种标准汇总元素。这些归纳操作返回<code>Collector</code>的实例，可以用他们作为<code>collect</code>操作的参数。<br>上例中的<code>Collectors.toList</code>将流元素累加到List的新实例中。<code>toList</code>操作返回了一个<code>Collector</code>实例，而不是一个集合。<br>下例中将<code>roster</code>集合元素根据性别归类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;Person.Sex, List&lt;Person&gt;&gt; byGender = roster.stream()</div><div class="line">        .collect(Collectors.groupingBy(Person::getGender));</div></pre></td></tr></table></figure></p>
<p>下例中根据性别将集合中元素的名字归类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Map&lt;Person.Sex, List&lt;String&gt;&gt; namesByGender =</div><div class="line">   roster.stream()</div><div class="line">       .collect(</div><div class="line">           Collectors.groupingBy(</div><div class="line">               Person::getGender,</div><div class="line">               Collectors.mapping(</div><div class="line">                   Person::getName,</div><div class="line">                   Collectors.toList())));</div></pre></td></tr></table></figure></p>
<p>以下示例检索每个性别成员的总年龄：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Map&lt;Person.Sex, Integer&gt; totalAgeByGender =</div><div class="line">    roster.stream()</div><div class="line">        .collect(</div><div class="line">            Collectors.groupingBy(</div><div class="line">                Person::getGender,                      </div><div class="line">                Collectors.reducing(</div><div class="line">                    0,</div><div class="line">                    Person::getAge,</div><div class="line">                    Integer::sum)));</div></pre></td></tr></table></figure></p>
<p>以下示例检索每个性别成员的平均年龄：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Map&lt;Person.Sex, Double&gt; averageAgeByGender = roster</div><div class="line">    .stream()</div><div class="line">    .collect(</div><div class="line">        Collectors.groupingBy(</div><div class="line">            Person::getGender,                      </div><div class="line">            Collectors.averagingInt(Person::getAge)));</div></pre></td></tr></table></figure></p>
<h2 id="并行处理流"><a href="#并行处理流" class="headerlink" title="并行处理流"></a>并行处理流</h2><p>并行计算包括将问题分解为子问题，同时解决这些问题（并行地，每个子问题在单独的线程中运行），然后将解决方案的结果组合。Java中有fork/join框架可以轻松地在应用程序中实现并行计算，不过需要问题是怎么分解成子问题的。在聚合操作中，Java运行时会自动处理分解和组合问题。<br>在应用程序中实现并行计算的一个主要难点是使用的集合不是线程安全的，这意味着多线程会导致线程之间的干扰或者内存一致性错误。集合框架提供了同步包装方法，可以通过包装任意集合，让他们成为线程安全的。但是，这会引入线程竞争，使得线程不能并行计算。聚合操作和并行处理流可以并行处理线程不安全的集合，而不用我们做修改。</p>
<blockquote>
<p>并行性并不会自动快于连续执行操作，即使有足够的数据和处理器内核，并行性也不会快。 虽然集合操作能够更轻松地实现并行性，但我们仍要确定应用程序是否适合并行性。<br>我们可以自己选择串行或者并行执行流。如果需要并行执行流，那么需要使用指定的方法：<code>Collection.parallelStream</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">double average = roster</div><div class="line">    .parallelStream()</div><div class="line">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</div><div class="line">    .mapToInt(Person::getAge)</div><div class="line">    .average()</div><div class="line">    .getAsDouble();</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="并行归纳"><a href="#并行归纳" class="headerlink" title="并行归纳"></a>并行归纳</h2><p>下例是我们串行处理流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Map&lt;Person.Sex, List&lt;Person&gt;&gt; byGender =</div><div class="line">    roster</div><div class="line">        .stream()</div><div class="line">        .collect(</div><div class="line">            Collectors.groupingBy(Person::getGender));</div></pre></td></tr></table></figure></p>
<p>其并行处理如下例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ConcurrentMap&lt;Person.Sex, List&lt;Person&gt;&gt; byGender =</div><div class="line">    roster</div><div class="line">        .parallelStream()</div><div class="line">        .collect(</div><div class="line">            Collectors.groupingByConcurrent(Person::getGender));</div></pre></td></tr></table></figure></p>
<p>用<code>groupingByConcurrent</code>代替了<code>groupingBy</code>，返回结果也有<code>Map</code>变为<code>ConcurrentMap</code>.</p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-08-21T11:32:12.791Z" itemprop="dateUpdated">2017-08-21 11:32:12</time>
</span><br>


        
    </div>
    <footer>
        <a href="http://wzhongke.github.io">
            <img src="/img/sign.jpg" alt="壹叶知秋">
            壹叶知秋
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://wzhongke.github.io/2017/07/20/Lambda表达式和Stream/&title=《Lambda表达式和Stream》 — 壹叶知秋的博客&pic=http://wzhongke.github.io/img/sign.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://wzhongke.github.io/2017/07/20/Lambda表达式和Stream/&title=《Lambda表达式和Stream》 — 壹叶知秋的博客&source=流被设计为与lambda表达式一起使用，这使得日常编程更容易。
Lambda 表达式匿名类的一个非常明显的问题是，如果匿名类的实现非常简单，例如只包含一个..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://wzhongke.github.io/2017/07/20/Lambda表达式和Stream/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Lambda表达式和Stream》 — 壹叶知秋的博客&url=http://wzhongke.github.io/2017/07/20/Lambda表达式和Stream/&via=http://wzhongke.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://wzhongke.github.io/2017/07/20/Lambda表达式和Stream/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/07/21/mybatis/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">mybatis</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/07/04/java/Java线程池技术/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">java线程池技术</h4>
      </a>
    </div>
  
</nav>



    














</article>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>壹叶知秋 &copy; 2015 - 2017</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://wzhongke.github.io/2017/07/20/Lambda表达式和Stream/&title=《Lambda表达式和Stream》 — 壹叶知秋的博客&pic=http://wzhongke.github.io/img/sign.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://wzhongke.github.io/2017/07/20/Lambda表达式和Stream/&title=《Lambda表达式和Stream》 — 壹叶知秋的博客&source=流被设计为与lambda表达式一起使用，这使得日常编程更容易。
Lambda 表达式匿名类的一个非常明显的问题是，如果匿名类的实现非常简单，例如只包含一个..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://wzhongke.github.io/2017/07/20/Lambda表达式和Stream/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Lambda表达式和Stream》 — 壹叶知秋的博客&url=http://wzhongke.github.io/2017/07/20/Lambda表达式和Stream/&via=http://wzhongke.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://wzhongke.github.io/2017/07/20/Lambda表达式和Stream/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://wzhongke.github.io/2017/07/20/Lambda表达式和Stream/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>








<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '你走了';
            clearTimeout(titleTime);
        } else {
            document.title = '你来了';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



<script>
    var codes = document.getElementsByClassName("code");
    var length = codes.length;
    for (var i=0; i<length; i++) {
        codes[i].innerHTML =  codes[i].innerHTML.replace(/&lt;b&gt;(.*?)&lt;\/b&gt;/g, "<b>$1</b>");
        console.log(codes[i].innerHTML)
    }

    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105841950-1', 'auto');
    ga('send', 'pageview');

</script>

</body>
</html>
