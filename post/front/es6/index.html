<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><title>es6 | World of Wang</title><meta name="viewport" content="width=device-width,user-scalable=no,maximum-scale=1,initial-scale=1"><link rel="canonical" href="https://wzhongke.github.io/post/front/es6/"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/ocean.min.css" rel="stylesheet"><link rel="stylesheet" href="https://wzhongke.github.io//css/index-ae15952095.css"><link href="https://wzhongke.github.io/index.xml" rel="alternate" type="application/rss+xml" title="World of Wang"><link href="https://wzhongke.github.io/index.xml" rel="feed" type="application/rss+xml" title="World of Wang"><link href="https://wzhongke.github.io//favicon.ico" rel="shortcut icon"><script>window.origin = "https://wzhongke.github.io/";
    
    var outer = document.createElement('div');
    outer.style.cssText = "visibility:hidden;width:100%;overflow:scroll";
    document.documentElement.appendChild(outer);
    window.scrollWidth = outer.offsetWidth - outer.clientWidth;
    document.documentElement.removeChild(outer);</script></head><body><div id="modal-search" class="modal"><div class="modal-content"><form><div class="row"><div class="input-field col s12"><input id="in-search" type="text" required aria-required="true" autofocus autocomplete="off"> <label for="in-search">Search</label></div></div></form><div class="out-wrapper row"><div id="out-search" class="collection col s12"></div></div></div></div><div class="navbar-fixed"><nav class="navbar"><div class="nav-wrapper container"><a href="javascript:void(0)" class="button-collapse"><i class="material-icons">menu</i></a> <a href="https://wzhongke.github.io/" class="brand-logo"><i class="material-icons">restaurant_menu</i> World of Wang</a><ul class="right hide-on-small-and-down"><li><a class="modal-trigger" href="#modal-search"><i class="material-icons">search</i></a></li><li><a href="https://wzhongke.github.io/index.xml" target="_blank"><i class="material-icons">rss_feed</i></a></li></ul><ul class="center tabs tabs-transparent hide-on-med-and-down"><li class="tab"><a href="https://wzhongke.github.io//" class="">Home</a></li><li class="tab"><a href="https://wzhongke.github.io//archive/" class="">Archive</a></li><li class="tab"><a href="https://wzhongke.github.io//about/" class="">About</a></li><li class="tab"><a href="https://wzhongke.github.io//post/%E7%A2%B0%E5%88%B0%E8%BF%87%E7%9A%84%E9%97%AE%E9%A2%98/" class="">碰到过的问题</a></li></ul></div></nav></div><aside class="side-panel"><div class="inner"><div class="profile"><div class="profile__bg" style="background-image:url('https://wzhongke.github.io//img/profile-bg-7c6e6a1672.jpg')"></div><img class="profile__avatar" src="https://wzhongke.github.io//img/sign-d1f802b4e8.jpg" alt="avatar"><h3 class="profile__name">壹冶知秋</h3><p class="profile__desc">Do not ride on fear...</p></div><ul class="nav-group show-on-medium-and-down menu"><li><a class="collapsible-header waves-effect waves-indigo" href="https://wzhongke.github.io//"><i class="material-icons">home</i> <span class="content">Home</span> <i class="material-icons">chevron_right</i></a></li><li><a class="collapsible-header waves-effect waves-indigo" href="https://wzhongke.github.io//archive/"><i class="material-icons">archive</i> <span class="content">Archive</span> <i class="material-icons">chevron_right</i></a></li><li><a class="collapsible-header waves-effect waves-indigo" href="https://wzhongke.github.io//about/"><i class="material-icons">person</i> <span class="content">About</span> <i class="material-icons">chevron_right</i></a></li><li><a class="collapsible-header waves-effect waves-indigo" href="https://wzhongke.github.io//post/%E7%A2%B0%E5%88%B0%E8%BF%87%E7%9A%84%E9%97%AE%E9%A2%98/"><i class="material-icons">bookmark</i> <span class="content">碰到过的问题</span> <i class="material-icons">chevron_right</i></a></li></ul><ul class="nav-group show-on-small tools"><li><a class="collapsible-header waves-effect waves-indigo modal-trigger" href="#modal-search"><i class="material-icons">search</i> <span class="content">Search</span> <i class="material-icons">chevron_right</i></a></li><li><a class="collapsible-header waves-effect waves-indigo" target="_blank" href="https://wzhongke.github.io/index.xml"><i class="material-icons">rss_feed</i> <span class="content">RSS Feed</span> <i class="material-icons">chevron_right</i></a></li></ul><ul class="collapsible nav-group" data-collapsible="accordion"><li><div class="collapsible-header waves-effect waves-indigo"><i class="material-icons">whatshot</i> <span class="content">Latest</span> <i class="material-icons angle">expand_more</i></div><div class="collapsible-body"><div class="collection"><a class="collection-item" href="https://wzhongke.github.io/post/">Posts</a> <a class="collection-item" href="https://wzhongke.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%80%9D%E8%80%83%E5%BF%AB%E4%B8%8E%E6%85%A2/">思考快与慢</a> <a class="collection-item" href="https://wzhongke.github.io/post/java/netty-%E5%AE%9E%E6%88%98/">netty 实战</a> <a class="collection-item" href="https://wzhongke.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/">非暴力沟通</a> <a class="collection-item" href="https://wzhongke.github.io/post/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7-%E5%8F%94%E6%9C%AC%E5%8D%8E/">人生的智慧_叔本华</a> <a class="collection-item" href="https://wzhongke.github.io/post/node/node%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">node使用笔记</a> <a class="collection-item" href="https://wzhongke.github.io/post/node/typeorm/">typeorm</a> <a class="collection-item" href="https://wzhongke.github.io/post/java/spring-%E6%BA%90%E7%A0%81/">深入浅出 nodejs</a> <a class="collection-item" href="https://wzhongke.github.io/post/java/java%E5%A0%86%E5%86%85%E5%AD%98/">java 内存以及GC</a> <a class="collection-item" href="https://wzhongke.github.io/post/java/java%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98/">java 使用代码计算内存</a></div></div></li><li><div class="collapsible-header waves-effect waves-indigo"><i class="material-icons"><i class="material-icons">class</i></i> <span class="content">Category </span><i class="material-icons angle">expand_more</i></div><div class="collapsible-body"><div class="collection"><a class="collection-item" href="https://wzhongke.github.io//categories/java">java<span class="badge">14</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/linux">linux<span class="badge">10</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/javascript">javascript<span class="badge">7</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/%E7%AE%97%E6%B3%95">算法<span class="badge">7</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/python">python<span class="badge">5</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式<span class="badge">5</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/mysql">mysql<span class="badge">4</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/other">other<span class="badge">4</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/%E5%B7%A5%E5%85%B7">工具<span class="badge">3</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0">读书笔记<span class="badge">3</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/css">css<span class="badge">2</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/sql">sql<span class="badge">2</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/error">error<span class="badge">1</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/markdown">markdown<span class="badge">1</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/nodejs">nodejs<span class="badge">1</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/svg">svg<span class="badge">1</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/vue">vue<span class="badge">1</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/%E6%97%85%E8%A1%8C">旅行<span class="badge">1</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/%E7%A4%BE%E7%A7%91">社科<span class="badge">1</span></a> <a class="collection-item" href="https://wzhongke.github.io//categories/%E7%BC%96%E7%A8%8B">编程<span class="badge">1</span></a></div></div></li><li><div class="collapsible-header waves-effect waves-indigo"><i class="material-icons"><i class="material-icons">local_offer</i></i> <span class="content">Tag </span><i class="material-icons angle">expand_more</i></div><div class="collapsible-body"><div class="collection"><a class="collection-item" href="https://wzhongke.github.io//tags/java">java<span class="badge">14</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/linux">linux<span class="badge">9</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/javascript">javascript<span class="badge">6</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/%E7%AE%97%E6%B3%95">算法<span class="badge">6</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/python">python<span class="badge">5</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式<span class="badge">5</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/mysql">mysql<span class="badge">4</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/other">other<span class="badge">4</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/%E5%B7%A5%E5%85%B7">工具<span class="badge">3</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/css">css<span class="badge">2</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/markdown">markdown<span class="badge">2</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/sql">sql<span class="badge">2</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0">读书笔记<span class="badge">2</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/error">error<span class="badge">1</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/nodejs">nodejs<span class="badge">1</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/svg">svg<span class="badge">1</span></a> <a class="collection-item" href="https://wzhongke.github.io//tags/%E6%97%85%E8%A1%8C">旅行<span class="badge">1</span></a></div></div></li></ul><ul class="nav-group external-link"><li><a class="collapsible-header waves-effect waves-indigo" href="https://github.com/wzhongke" target="_blank"><svg class="svg-icons svg-icons-github"><use xlink:href="#svg-icons-github"></use></svg> <span class="content">Github<small>@wzhongke</small></span> <i class="material-icons">chevron_right</i></a></li></ul></div></aside><main id="single" role="main" class="main-panel"><section class="container"><div class="inner"><div class="breadcrumbs" role="navigation" aria-label="breadcrumbs navigation"><a class="breadcrumb" href="https://wzhongke.github.io/"><i class="material-icons">location_on</i>Home</a> <a class="breadcrumb" href="https://wzhongke.github.io/post/">Post</a> <a class="breadcrumb" href="https://wzhongke.github.io/post/front/">Front</a> <span class="breadcrumb">es6</span></div><section class="post-wrapper"><div class="toc-panel"><nav id="TableOfContents"><ul><li><a href="#使用">使用</a></li></ul><ul><li><a href="#const">const</a></li></ul><ul><li><a href="#解构的应用">解构的应用</a></li></ul><ul><li><a href="#字符串遍历">字符串遍历</a></li><li><a href="#normalize">normalize()</a></li><li><a href="#包含">包含</a></li><li><a href="#repeat">repeat()</a></li><li><a href="#字符串补全">字符串补全</a></li><li><a href="#模板字符串">模板字符串</a></li><li><a href="#标签模板">标签模板</a></li></ul><ul><li><a href="#箭头函数">箭头函数</a></li><li><a href="#函数绑定运算符">函数绑定运算符</a></li></ul><ul><li><a href="#数组扩展运算符">数组扩展运算符</a></li><li><a href="#arrayfrom"><code>Array.from()</code></a></li><li><a href="#arrayof"><code>Array.of()</code></a></li><li><a href="#数组的copywithin方法">数组的<code>copyWithin</code>方法</a></li><li><a href="#find-和-findindex"><code>find</code> 和 <code>findIndex</code></a></li><li><a href="#数组遍历方式">数组遍历方式</a></li><li><a href="#数组包含">数组包含</a></li></ul><ul><li><a href="#属性简介表示">属性简介表示</a></li><li><a href="#属性名">属性名</a></li><li><a href="#objectassign">Object.assign()</a></li><li><a href="#属性的枚举和遍历">属性的枚举和遍历</a></li></ul><ul><li><a href="#map-同其他数据结构互转"><code>Map</code> 同其他数据结构互转</a></li></ul><ul><li><a href="#代理对象的this指向问题">代理对象的this指向问题</a></li><li><a href="#reflect-类"><code>Reflect</code> 类</a></li></ul><ul><li><a href="#promiseprototypethen"><code>Promise.prototype.then()</code></a></li><li><a href="#promiseprototypecatch"><code>Promise.prototype.catch()</code></a></li><li><a href="#promiseprototypefinally"><code>Promise.prototype.finally()</code></a></li><li><a href="#promiseprototypeallpromise"><code>Promise.prototype.all([...promise])</code></a></li><li><a href="#promiseprototyperace"><code>Promise.prototype.race()</code></a></li><li><a href="#promiseprototyperesolve"><code>Promise.prototype.resolve()</code></a></li><li><a href="#promiseprototypereject"><code>Promise.prototype.reject()</code></a></li></ul><ul><li><a href="#next-方法"><code>next()</code> 方法</a></li><li><a href="#for--of-"><code>for .. of ..</code></a></li><li><a href="#generatorprototypethrow"><code>Generator.prototype.throw()</code></a></li><li><a href="#generatorprototypereturn"><code>Generator.prototype.return()</code></a></li><li><a href="#yield-表达式"><code>yield*</code> 表达式</a></li><li><a href="#对象中的-generator-函数">对象中的 Generator 函数</a></li><li><a href="#generator-的应用">Generator 的应用</a></li></ul><ul><li><a href="#trunk-函数">Trunk 函数</a></li><li><a href="#使用-thunkify-模块">使用 <code>Thunkify</code> 模块</a></li><li><a href="#generator-流程管理">Generator 流程管理</a></li></ul><ul><li><a href="#使用-1">使用</a></li><li><a href="#async-错误处理"><code>async</code> 错误处理</a></li></ul><ul><li><a href="#构造器方法">构造器方法</a></li><li><a href="#实例对象">实例对象</a></li><li><a href="#class-表达式">class 表达式</a></li><li><a href="#getter-和-setter-方法">getter 和 setter 方法</a></li><li><a href="#静态方法">静态方法</a></li><li><a href="#class-的静态属性和实例属性">class 的静态属性和实例属性</a></li><li><a href="#newtarget-属性"><code>new.target</code> 属性</a></li></ul><ul><li><a href="#类的prototype属性和__proto__属性">类的<code>prototype</code>属性和<code>__proto__</code>属性</a></li><li><a href="#继承目标">继承目标</a></li><li><a href="#mixin-模式实现">Mixin 模式实现</a></li></ul><ul><li><a href="#export"><code>export</code></a></li><li><a href="#import"><code>import</code></a></li><li><a href="#整体加载模块">整体加载模块</a></li><li><a href="#export-default-命令"><code>export default</code> 命令</a></li><li><a href="#export-和-import-同时使用"><code>export</code> 和 <code>import</code> 同时使用</a></li><li><a href="#模块的继承">模块的继承</a></li><li><a href="#跨模块常量">跨模块常量</a></li></ul></nav></div><div class="post"><div class="card"><div class="card-content"><span class="card-title">es6 </span><span class="card-meta"><time><span>Sat Apr 21 2018</span></time><address><a href="https://wzhongke.github.io//categories/javascript">javascript</a>&nbsp;</address></span><article class="article"><h1 id="babel-es6-转换成-es5">babel: ES6 转换成 ES5</h1><p>babel 是一个将ES6转换成ES5的转码器，babel的配置文件是 <code>.babelrc</code>，存放在项目的根目录。 全局安装babel：</p><pre><code>$ npm install --global babel-cli
</code></pre><p>配置文件如下：</p><pre><code>{
    &quot;presets&quot;: [
      &quot;latest&quot;,
      &quot;react&quot;,
      &quot;stage-2&quot;
    ],
    &quot;plugins&quot;: []
  }
</code></pre><p>安装转码规则方式如下：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 最新转码规则</span>
$ npm install --save-dev babel-preset-latest

<span style="color:#75715e"># react 转码规则</span>
$ npm install --save-dev babel-preset-react

<span style="color:#75715e"># 不同阶段语法提案的转码规则（共有4个阶段），选装一个</span>
$ npm install --save-dev babel-preset-stage-0
$ npm install --save-dev babel-preset-stage-1
$ npm install --save-dev babel-preset-stage-2
$ npm install --save-dev babel-preset-stage-3
</code></pre></div><h2 id="使用">使用</h2><p>babel的基本用法如下：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 转码结果输出到标准输出</span>
$ babel example.js

<span style="color:#75715e"># 转码结果写入一个文件</span>
<span style="color:#75715e"># --out-file 或 -o 参数指定输出文件</span>
$ babel example.js --out-file compiled.js
<span style="color:#75715e"># 或者</span>
$ babel example.js -o compiled.js

<span style="color:#75715e"># 整个目录转码</span>
<span style="color:#75715e"># --out-dir 或 -d 参数指定输出目录</span>
$ babel src --out-dir lib
<span style="color:#75715e"># 或者</span>
$ babel src -d lib

<span style="color:#75715e"># -s 参数生成source map文件</span>
$ babel src -d lib -s
</code></pre></div><h1 id="let-关键字">let 关键字</h1><p><code>let</code> 同 <code>var</code> 类似，但是声明的变量，只在 <code>let</code> 命令所在的代码块内有效。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [];
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
    <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">i</span>);
    };
}
<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">6</span>](); <span style="color:#75715e">// 10
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> [];

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
    <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">i</span>);
    };
}
<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">6</span>](); <span style="color:#75715e">// 6
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// for 循环中，设置循环变量 let i=0 中的 i 是一个父作用域
</span><span style="color:#75715e">// 循环体内是一个单独的子作用域
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;123&#39;</span>;
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">i</span>); <span style="color:#75715e">// 123
</span><span style="color:#75715e"></span>}
</code></pre></div><p><strong><code>let</code> 声明的变量必须在声明之后使用，否则会报错，而且在变量作用域内，变量声明之前不可以使用该变量</strong>。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">x</span>; <span style="color:#75715e">// 会抛出错误： ReferenceError
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span>;
</code></pre></div><h2 id="const">const</h2><p><code>const</code> 声明一个只读的常量，一旦声明，常量的值就不能改变。这意味着 <code>const</code> 声明的变量必须立即初始化，而且其声明的变量同 <code>let</code> 一样就有块级作用域。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">true</span>) {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">PI</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
}
<span style="color:#a6e22e">PI</span> <span style="color:#75715e">// PI is not defined.
</span></code></pre></div><p>同java中的常量一样，不能够修改其指向的内存地址，却可以修改对象的属性，比如：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">CONST</span> <span style="color:#f92672">=</span> {};
<span style="color:#a6e22e">CONST</span>.<span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>;
</code></pre></div><p>如果想要冻结一个对象，可以使用如下方式：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">constantize</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">obj</span>) =&gt; {
    Object.<span style="color:#a6e22e">freeze</span>(<span style="color:#a6e22e">obj</span>);
    Object.<span style="color:#a6e22e">keys</span>(<span style="color:#a6e22e">obj</span>).<span style="color:#a6e22e">forEach</span>( (<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">i</span>) =&gt; {
        <span style="color:#66d9ef">if</span> ( <span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">obj</span>[<span style="color:#a6e22e">key</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;object&#39;</span> ) {
            <span style="color:#a6e22e">constantize</span>( <span style="color:#a6e22e">obj</span>[<span style="color:#a6e22e">key</span>] );
        }
    });
};
</code></pre></div><h1 id="数组">数组</h1><p>对于数组解构赋值可以用如下方式：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
<span style="color:#a6e22e">a</span> <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span> <span style="color:#75715e">// 2
</span><span style="color:#75715e"></span><span style="color:#a6e22e">c</span> <span style="color:#75715e">//3
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">let</span> [ , , <span style="color:#a6e22e">third</span>] <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;foo&#34;</span>, <span style="color:#e6db74">&#34;bar&#34;</span>, <span style="color:#e6db74">&#34;baz&#34;</span>];
<span style="color:#a6e22e">third</span> <span style="color:#75715e">// &#34;baz&#34;
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">head</span>, ...<span style="color:#a6e22e">tail</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>];
<span style="color:#a6e22e">head</span> <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span><span style="color:#a6e22e">tail</span> <span style="color:#75715e">// [2, 3, 4]
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 如果解构不成功，那么变量的值就等于 undefined
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">foo</span>] <span style="color:#f92672">=</span> [];
<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">bar</span>, <span style="color:#a6e22e">foo</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>];
<span style="color:#a6e22e">foo</span> <span style="color:#75715e">// undefined
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 指定默认值，当 y===undefined 时，默认值才生效
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#39;b&#39;</span>] <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#66d9ef">undefined</span>] <span style="color:#75715e">// y=&#39;b&#39;
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 对对象进行解构
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">p</span><span style="color:#f92672">:</span> [
    <span style="color:#e6db74">&#39;Hello&#39;</span>,
    { <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;World&#39;</span> }
  ]
};

<span style="color:#66d9ef">let</span> { <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">p</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">x</span>, { <span style="color:#a6e22e">y</span> }] } <span style="color:#f92672">=</span> <span style="color:#a6e22e">obj</span>;
<span style="color:#a6e22e">x</span> <span style="color:#75715e">// &#34;Hello&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">y</span> <span style="color:#75715e">// &#34;World&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">p</span> <span style="color:#75715e">// [&#34;Hello&#34;, {y: &#34;World&#34;}]
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 字符串解构
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;he&#39;</span>;
<span style="color:#a6e22e">a</span> <span style="color:#75715e">// &#34;h&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span> <span style="color:#75715e">// &#34;e&#34;
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 第一个是对象的属性值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> {<span style="color:#a6e22e">length</span> <span style="color:#f92672">:</span> <span style="color:#a6e22e">len</span>} <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;he&#39;</span>;
<span style="color:#a6e22e">len</span> <span style="color:#75715e">// 2
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 对函数的解构，也可以使用默认值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">move</span>({<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>} <span style="color:#f92672">=</span> {}) {
  <span style="color:#66d9ef">return</span> [<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>];
}

<span style="color:#a6e22e">move</span>({<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">8</span>}); <span style="color:#75715e">// [3, 8]
</span><span style="color:#75715e"></span><span style="color:#a6e22e">move</span>({<span style="color:#a6e22e">x</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>}); <span style="color:#75715e">// [3, 0]
</span><span style="color:#75715e"></span><span style="color:#a6e22e">move</span>({}); <span style="color:#75715e">// [0, 0]
</span><span style="color:#75715e"></span><span style="color:#a6e22e">move</span>(); <span style="color:#75715e">// [0, 0]
</span></code></pre></div><p>对于解构，需要等号右边是的数据结构具有 Iterator 接口才能够解构成功，否则会报错。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">fibs</span> () {
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
        <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">a</span>;
        [<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>] <span style="color:#f92672">=</span> [<span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">a</span><span style="color:#f92672">+</span><span style="color:#a6e22e">b</span>];
    }
}

<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">first</span>, <span style="color:#a6e22e">second</span>, <span style="color:#a6e22e">third</span>, <span style="color:#a6e22e">fourth</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">fibs</span>();
<span style="color:#a6e22e">fourth</span> <span style="color:#75715e">// 2
</span></code></pre></div><h2 id="解构的应用">解构的应用</h2><ol><li>变量交换</li></ol><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
[<span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span>] <span style="color:#f92672">=</span> [<span style="color:#a6e22e">y</span>,<span style="color:#a6e22e">x</span>];
</code></pre></div><ol start="2"><li>函数返回多个值</li></ol><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">example</span>() {
    <span style="color:#66d9ef">return</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
}
<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">example</span>();
</code></pre></div><ol start="3"><li>函数参数的定义</li></ol><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>([<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">z</span>]) { ... }
<span style="color:#a6e22e">f</span>([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]);
<span style="color:#a6e22e">f</span>({<span style="color:#a6e22e">z</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">:</span><span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">x</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>});
</code></pre></div><ol start="4"><li>提取JSON数据</li></ol><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">jsonData</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">id</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">42</span>,
    <span style="color:#a6e22e">status</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;OK&#34;</span>,
    <span style="color:#a6e22e">data</span><span style="color:#f92672">:</span> [<span style="color:#ae81ff">867</span>, <span style="color:#ae81ff">5309</span>]
};

<span style="color:#66d9ef">let</span> { <span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">data</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">number</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">jsonData</span>;
</code></pre></div><ol start="5"><li>遍历map解构</li></ol><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">map</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>();
<span style="color:#a6e22e">map</span>.<span style="color:#a6e22e">set</span>(<span style="color:#e6db74">&#39;first&#39;</span>, <span style="color:#e6db74">&#39;hello&#39;</span>);
<span style="color:#a6e22e">map</span>.<span style="color:#a6e22e">set</span>(<span style="color:#e6db74">&#39;second&#39;</span>, <span style="color:#e6db74">&#39;world&#39;</span>);

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>] <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">map</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">key</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; is &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">value</span>);
}

<span style="color:#75715e">// 获取键名
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">key</span>] <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">map</span>) {
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 获取键值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> [,<span style="color:#a6e22e">value</span>] <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">map</span>) {
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><h1 id="字符串">字符串</h1><p>ES6对字符串做了些扩展</p><h2 id="字符串遍历">字符串遍历</h2><p>ES6为字符串提供了遍历器接口：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">of</span> <span style="color:#e6db74">&#39;test&#39;</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">c</span>);
}

<span style="color:#75715e">// 可以识别大于 0xFFFF 的码
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">of</span> String.<span style="color:#a6e22e">fromCodePoint</span>(<span style="color:#ae81ff">0x20BB7</span>)) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">c</span>);
}
</code></pre></div><h2 id="normalize">normalize()</h2><p><code>normalize()</code> 方法把字符的不同表示方法统一为同样的形式，目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#e6db74">&#39;\u01D1&#39;</span>.<span style="color:#a6e22e">normalize</span>() <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;\u004F\u030C&#39;</span>.<span style="color:#a6e22e">normalize</span>() <span style="color:#75715e">//true
</span></code></pre></div><h2 id="包含">包含</h2><ul><li>includes(s, startPos)：返回布尔值，表示是否找到了参数字符串。</li><li>startsWith(s, startPos)：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li>endsWith(s, startPos)：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><h2 id="repeat">repeat()</h2><p>返回重复次数的字符串:</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#e6db74">&#39;hello&#39;</span>.<span style="color:#a6e22e">repate</span>(<span style="color:#ae81ff">2</span>); <span style="color:#75715e">// hellohello
</span></code></pre></div><h2 id="字符串补全">字符串补全</h2><p>字符串长度补全功能如下：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#e6db74">&#39;x&#39;</span>.<span style="color:#a6e22e">padStart</span>(<span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#39;ab&#39;</span>) <span style="color:#75715e">// &#39;ababx&#39;
</span><span style="color:#75715e"></span><span style="color:#e6db74">&#39;x&#39;</span>.<span style="color:#a6e22e">padStart</span>(<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;ab&#39;</span>) <span style="color:#75715e">// &#39;abax&#39;
</span><span style="color:#75715e"></span>
<span style="color:#e6db74">&#39;x&#39;</span>.<span style="color:#a6e22e">padEnd</span>(<span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#39;ab&#39;</span>) <span style="color:#75715e">// &#39;xabab&#39;
</span><span style="color:#75715e"></span><span style="color:#e6db74">&#39;x&#39;</span>.<span style="color:#a6e22e">padEnd</span>(<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;ab&#39;</span>) <span style="color:#75715e">// &#39;xaba&#39;
</span></code></pre></div><h2 id="模板字符串">模板字符串</h2><p>模板字符串（template string）是增强版的字符串，用反引号（<code>）标识。 它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。可以在</code>${ &hellip; }` 中放入任何合法的JavaScript表达式</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 将变量使用 ${} 嵌入到模板中
</span><span style="color:#75715e"></span><span style="color:#a6e22e">$</span>(<span style="color:#e6db74">&#39;#result&#39;</span>).<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">`
</span><span style="color:#e6db74">    There are &lt;b&gt;</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">basket</span>.<span style="color:#a6e22e">count</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&lt;/b&gt; items
</span><span style="color:#e6db74">    in your basket, &lt;em&gt;</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">basket</span>.<span style="color:#a6e22e">onSale</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&lt;/em&gt;
</span><span style="color:#e6db74">    are on sale!
</span><span style="color:#e6db74">`</span>);
</code></pre></div><h2 id="标签模板">标签模板</h2><p>模板可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">alert</span><span style="color:#e6db74">`123`</span>; <span style="color:#75715e">// 等同于 alert(123)
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 模板中有变量的情况
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">a</span><span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">b</span><span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>;
<span style="color:#a6e22e">tag</span><span style="color:#e6db74">`Hello </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">a</span><span style="color:#f92672">+</span><span style="color:#a6e22e">b</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> word </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">a</span><span style="color:#f92672">*</span><span style="color:#a6e22e">b</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
<span style="color:#a6e22e">tag</span>([<span style="color:#e6db74">&#39;Hello &#39;</span>, <span style="color:#e6db74">&#39; word &#39;</span>,<span style="color:#e6db74">&#39;&#39;</span>], <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">50</span>);
<span style="color:#75715e">// tag 是一种这样的函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">tag</span> (<span style="color:#a6e22e">stringArr</span>, ...<span style="color:#a6e22e">values</span>) {}

<span style="color:#75715e">// 过滤HTML字符串
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">message</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">SafeHTML</span><span style="color:#e6db74">`&lt;p&gt;</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">sender</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> has sent you a message.&lt;/p&gt;`</span>;
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SafeHTML</span> (<span style="color:#a6e22e">templateData</span>) {
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">templateData</span>[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">arguments</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arg</span> <span style="color:#f92672">=</span> String(<span style="color:#a6e22e">arguments</span>[<span style="color:#a6e22e">i</span>]);

        <span style="color:#a6e22e">s</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">arg</span>.<span style="color:#a6e22e">replace</span>(<span style="color:#e6db74">/&amp;/g</span>, <span style="color:#e6db74">&#34;&amp;amp;&#34;</span>)
              .<span style="color:#a6e22e">replace</span>(<span style="color:#e6db74">/&lt;/g</span>, <span style="color:#e6db74">&#34;&amp;lt;&#34;</span>)
              .<span style="color:#a6e22e">replace</span>(<span style="color:#e6db74">/&gt;/g</span>, <span style="color:#e6db74">&#34;&amp;gt;&#34;</span>);

        <span style="color:#a6e22e">s</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">templateData</span>[<span style="color:#a6e22e">i</span>];
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>;
}
</code></pre></div><h1 id="函数扩展">函数扩展</h1><p>ES6 允许为函数的参数指定默认值，如下：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) {}
<span style="color:#75715e">// 参数默认值不是传值的，每次都会重新计算
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>;
}
<span style="color:#a6e22e">f</span>(); <span style="color:#75715e">// 2
</span><span style="color:#75715e"></span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
<span style="color:#a6e22e">f</span>(); <span style="color:#75715e">//3
</span></code></pre></div><p>ES6 还引入了 rest 参数，即 <code>... value</code>，用于获取函数多余的参数，这样就无需使用 <code>arguments</code> 对象。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">add</span>(...<span style="color:#a6e22e">values</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">val</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">values</span>) {
    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">val</span>;
  }

  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>;
}

<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">3</span>) <span style="color:#75715e">// 10
</span></code></pre></div><h2 id="箭头函数">箭头函数</h2><p>ES6 中允许使用 <code>=&gt;</code> 定义函数：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">v</span> =&gt; <span style="color:#a6e22e">v</span>;
<span style="color:#75715e">// 等价于
</span><span style="color:#75715e"></span><span style="color:#a6e22e">lef</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fucntion</span>(<span style="color:#a6e22e">v</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>;
};
</code></pre></div><p>如果函数需要多个参数或者不需要参数，就要使用圆括号代表参数部分；如果函数体中有大于一条语句，就要用大括号括起来：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">f</span> <span style="color:#f92672">=</span> () =&gt; <span style="color:#ae81ff">5</span>;
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) =&gt; {<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>;};
</code></pre></div><p><strong>箭头函数体内的<code>this</code>对象，就是指向定义时所在的对象，而不是使用时所在的对象。</strong> 即箭头函数中的<code>this</code>指向固化了，这是因为箭头函数中没有自己的<code>this</code>，而是引用外层的<code>this</code>.</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">foo</span>() {
  <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;id:&#39;</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">id</span>);
  }, <span style="color:#ae81ff">100</span>);
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">id</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">21</span>;
<span style="color:#a6e22e">foo</span>.<span style="color:#a6e22e">call</span>({ <span style="color:#a6e22e">id</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">42</span> }); <span style="color:#75715e">// id: 42
</span></code></pre></div><h2 id="函数绑定运算符">函数绑定运算符</h2><p><code>::</code> 是函数绑定运算符，它将左边的对象做为上下文环境（<code>this</code>）绑定到右边的函数上。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">foo</span><span style="color:#f92672">::</span><span style="color:#a6e22e">bar</span>;
<span style="color:#75715e">// 等同于
</span><span style="color:#75715e"></span><span style="color:#a6e22e">bar</span>.<span style="color:#a6e22e">bind</span>(<span style="color:#a6e22e">foo</span>);

<span style="color:#75715e">//如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">method</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">obj</span><span style="color:#f92672">::</span><span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">foo</span>;
<span style="color:#75715e">// 等同于
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">method</span> <span style="color:#f92672">=</span> <span style="color:#f92672">::</span><span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">foo</span>;
</code></pre></div><h1 id="数组-1">数组</h1><h2 id="数组扩展运算符">数组扩展运算符</h2><p>扩展运算符<code>...</code>，将一个数组转换成逗号分隔的参数序列。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(...[<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>]) <span style="color:#75715e">// 1,2,3
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>;
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">numbers</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">38</span>];
<span style="color:#a6e22e">add</span>(...<span style="color:#a6e22e">numbers</span>) <span style="color:#75715e">// 42
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// ES6 的写法，可以不将数组转换成序列
</span><span style="color:#75715e"></span>Math.<span style="color:#a6e22e">max</span>(...[<span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">77</span>])

<span style="color:#75715e">// 等同于
</span><span style="color:#75715e"></span>Math.<span style="color:#a6e22e">max</span>(<span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">77</span>);

<span style="color:#75715e">// 字符串扩展
</span><span style="color:#75715e"></span>[...<span style="color:#e6db74">&#39;hello&#39;</span>] <span style="color:#75715e">//  [ &#34;h&#34;, &#34;e&#34;, &#34;l&#34;, &#34;l&#34;, &#34;o&#34; ]
</span></code></pre></div><h2 id="arrayfrom"><code>Array.from()</code></h2><p><code>Array.from()</code> 可以将类数组对象或者具有Iterator接口的对象转换成数组。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">Array.<span style="color:#a6e22e">from</span>(<span style="color:#e6db74">&#39;hello&#39;</span>)  <span style="color:#75715e">// [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 第二个参数用来处理数组中每个元素
</span><span style="color:#75715e"></span>Array.<span style="color:#a6e22e">from</span>(<span style="color:#a6e22e">arrayLike</span>, <span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>);
<span style="color:#75715e">// 等同于
</span><span style="color:#75715e"></span>Array.<span style="color:#a6e22e">from</span>(<span style="color:#a6e22e">arrayLike</span>).<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>);
</code></pre></div><h2 id="arrayof"><code>Array.of()</code></h2><p><code>Array.of()</code> 用来将一组值转换成数组。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">Array.<span style="color:#66d9ef">of</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">8</span>) <span style="color:#75715e">// [3,11,8]
</span></code></pre></div><h2 id="数组的copywithin方法">数组的<code>copyWithin</code>方法</h2><p><code>copyWithin(target, start=0, end=this.length)</code> 方法会在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组，会修改数组。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>].<span style="color:#a6e22e">copyWithin</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>) <span style="color:#75715e">// [4, 5, 3, 4, 5]
</span></code></pre></div><p>该方法接收3个参数：</p><ul><li>target ： 开始替换数据的位置</li><li>start ：读取数据开始的位置</li><li>end ： 在该位置之前， 停止读取数据</li></ul><h2 id="find-和-findindex"><code>find</code> 和 <code>findIndex</code></h2><p><code>find</code> 方法用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员。如果没有返回值为true的成员，则返回undefined。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// find 的回调函数的参数依次是 值，下标，数组
</span><span style="color:#75715e"></span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">15</span>].<span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">arr</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">9</span>;
}) 
</code></pre></div><p><code>findIndex</code> 同 <code>find</code> 类似，只是返回的是第一个符合条件的数组的下标，若没有符合条件的成员，返回-1.</p><h2 id="数组遍历方式">数组遍历方式</h2><p>可以使用数组的 <code>keys()</code>、<code>values()</code> 和 <code>entries()</code>来遍历一个数组，分别返回的是键、值和键值对。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 键，也就是下标
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">index</span> <span style="color:#66d9ef">of</span> [<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>].<span style="color:#a6e22e">keys</span>()) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">index</span>);
}
<span style="color:#75715e">// 0, 1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">of</span> [<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>].<span style="color:#a6e22e">values</span>()) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
}
<span style="color:#75715e">// &#34;a&#34;, &#34;b&#34;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">elem</span>] <span style="color:#66d9ef">of</span> [<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>].<span style="color:#a6e22e">entries</span>()) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>()
}

</code></pre></div><h2 id="数组包含">数组包含</h2><p><code>Array.prototype.includes(value, start=0)</code> 方法返回一个布尔值，表示某个数组是否包含给定的值。 <code>value</code> 是要查找的值，<code>start</code> 是开始查找的位置，如果是负数，则从倒数位置开始</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>].<span style="color:#a6e22e">includes</span>(<span style="color:#ae81ff">2</span>)     <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>].<span style="color:#a6e22e">includes</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>);  <span style="color:#75715e">// false
</span></code></pre></div><h1 id="对象扩展">对象扩展</h1><h2 id="属性简介表示">属性简介表示</h2><p>ES6可以在对象中直接写变量，这时属性名为变量名，属性值为变量值。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">foo</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;bar&#39;</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">baz</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">foo</span>};
<span style="color:#a6e22e">baz</span> <span style="color:#75715e">// {foo: &#34;bar&#34;}
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 等同于
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">baz</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">foo</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">foo</span>};

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) {
    <span style="color:#66d9ef">return</span> {<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>};
}

<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>) <span style="color:#75715e">// {x:1, y:2}
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 方法简写
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">method</span>() {
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Hello!&#34;</span>;
    }
};
<span style="color:#75715e">// 等同于
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">method</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Hello!&#34;</span>;
    }
}
</code></pre></div><p>CommonJS 模块输出一组变量，就可以用如下方式：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">ms</span> <span style="color:#f92672">=</span> {};

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getItem</span> (<span style="color:#a6e22e">key</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">key</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">ms</span> <span style="color:#f92672">?</span> <span style="color:#a6e22e">ms</span>[<span style="color:#a6e22e">key</span>] <span style="color:#f92672">:</span> <span style="color:#66d9ef">null</span>;
}
<span style="color:#a6e22e">module</span>.<span style="color:#a6e22e">exports</span> <span style="color:#f92672">=</span> {<span style="color:#a6e22e">getItem</span>};
<span style="color:#75715e">// 等同于
</span><span style="color:#75715e"></span><span style="color:#a6e22e">module</span>.<span style="color:#a6e22e">exports</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">getItem</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">getItem</span>
}
</code></pre></div><p>方法的get和set简写</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">cart</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">_wheels</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>,

  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">wheels</span> () {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_wheels</span>;
  },

  <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">wheels</span> (<span style="color:#a6e22e">value</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">value</span> <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_wheels</span>) {
      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#39;数值太小了！&#39;</span>);
    }
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_wheels</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
  }
}
<span style="color:#a6e22e">cart</span>.<span style="color:#a6e22e">wheels</span> <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span><span style="color:#a6e22e">cart</span>.<span style="color:#a6e22e">wheels</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Uncaught Error: 数值太小了！
</span><span style="color:#75715e"></span>
</code></pre></div><h2 id="属性名">属性名</h2><p>ES6 中可以用表达式定义变量名或方法名：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">propKey</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;foo&#39;</span>;

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {
    [<span style="color:#a6e22e">propKey</span>]<span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>,
    [<span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;bc&#39;</span>]<span style="color:#f92672">:</span> <span style="color:#ae81ff">123</span>
};

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {
    [<span style="color:#e6db74">&#39;h&#39;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;ello&#39;</span>]() {
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;hi&#39;</span>;
    }
};

<span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">hello</span>() <span style="color:#75715e">// hi
</span></code></pre></div><h2 id="objectassign">Object.assign()</h2><p><code>Object.assign(target, source1, source2, ...);</code> 用于将源对象所有可枚举的属性复制到目标对象中。 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 <strong>Object.assign() 是浅拷贝</strong></p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">target</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">a</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">b</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span> };

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">source1</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">b</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">c</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span> };
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">source2</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">c</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span> };

Object.<span style="color:#a6e22e">assign</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">source1</span>, <span style="color:#a6e22e">source2</span>);
<span style="color:#a6e22e">target</span> <span style="color:#75715e">// {a:1, b:2, c:3}
</span></code></pre></div><p>比较常用的用途如下：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 为对象添加属性
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span> {
    <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) {
        Object.<span style="color:#a6e22e">assign</span>(<span style="color:#66d9ef">this</span>, {<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>});
    }
}

<span style="color:#75715e">// 为对象添加方法
</span><span style="color:#75715e"></span>Object.<span style="color:#a6e22e">assign</span>(<span style="color:#a6e22e">SomeClass</span>.<span style="color:#a6e22e">prototype</span>, {
    <span style="color:#a6e22e">someMethod</span>(<span style="color:#a6e22e">arg1</span>, <span style="color:#a6e22e">arg2</span>) { },
    <span style="color:#a6e22e">anotherMethod</span>() { }
});

<span style="color:#75715e">// 合并对象
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">merge</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">target</span>, ...<span style="color:#a6e22e">sources</span>) =&gt; Object.<span style="color:#a6e22e">assign</span>(<span style="color:#a6e22e">target</span>, ...<span style="color:#a6e22e">sources</span>);

<span style="color:#75715e">// 为对象指定默认值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">DEFAULTS</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">logLevel</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>,
  <span style="color:#a6e22e">outputFormat</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;html&#39;</span>
};
<span style="color:#a6e22e">options</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">assign</span>({}, <span style="color:#a6e22e">DEFAULTS</span>, <span style="color:#a6e22e">options</span>);
</code></pre></div><h2 id="属性的枚举和遍历">属性的枚举和遍历</h2><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。 描述对象的属性<code>enumerable</code>为<code>false</code>时，表明该属性是不可枚举的。下面四个操作会忽略不可枚举的属性。</p><ul><li><code>for...in</code> ： 只遍历对象自身的和继承的可枚举的属性。</li><li><code>Object.keys()</code> ：返回对象自身的所有可枚举的属性的键名。</li><li><code>JSON.stringify()</code> ：只串行化对象自身的可枚举的属性。</li><li><code>Object.assign()</code> ： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</li></ul><h1 id="set-数据结构"><code>Set</code> 数据结构</h1><p>ES6 提供了新的数据结构<code>Set</code>，它成员的值是唯一的，不存在重复的值。<code>Set</code> 可以用数组作为参数来初始化。 向<code>Set</code> 加入值时，不会进行类型转换，它是用 <code>===</code> 来判断两个值是否相等的。但是两个对象是不相等的。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">set</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Set</span>([<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>]); <span style="color:#75715e">// [1,2,3,4]
</span></code></pre></div><p>对 <code>Set</code> 集合的操作主要有如下四种方法：</p><ul><li><code>add(value)</code> : 添加值，返回Set本身，可以链式调用</li><li><code>has(value)</code> : 判断值是否在Set中，返回布尔值</li><li><code>delete(value)</code> : 删除值，返回是否删除</li><li><code>clear()</code> : 清空所有成员</li></ul><p><code>Set</code> 有四种遍历方法，因为它只有值没有键，所以key和value都是它的值。</p><ul><li><code>keys()</code> : 返回键名的遍历器</li><li><code>values()</code> : 返回键值的遍历器</li><li><code>entries()</code> : 返回键值对的遍历器</li><li><code>forEach()</code> : 使用回调函数遍历每个成员</li></ul><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">set</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Set</span>([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]);
<span style="color:#a6e22e">set</span>.<span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#39;color&#39;</span>);

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">set</span>.<span style="color:#a6e22e">keys</span>()) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span>);
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">set</span>.<span style="color:#a6e22e">values</span>()) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span>);
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>] <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">set</span>.<span style="color:#a6e22e">entries</span>()) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">key</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; : &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">value</span>);
}

<span style="color:#a6e22e">set</span>.<span style="color:#a6e22e">forEach</span>((<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">setSelf</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">key</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39; : &#39;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">value</span>))

<span style="color:#75715e">// 将set集合转换成数组，这样就可以使用数组的 map、filter等方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> [...<span style="color:#a6e22e">set</span>];
<span style="color:#75715e">// 直接改变数组中的值
</span><span style="color:#75715e"></span><span style="color:#a6e22e">set</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Set</span>([...<span style="color:#a6e22e">set</span>].<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">val</span> =&gt; <span style="color:#a6e22e">val</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>));
</code></pre></div><h1 id="map-数据结构"><code>Map</code> 数据结构</h1><p>任何具有 <code>Iterator</code> 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。 <code>Map</code> 的键是跟内存地址绑定的，只要内存地址不一样，就视为两个键。如果 <code>Map</code> 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，<code>Map</code> 将其视为一个键。</p><p><code>Map</code> 有以下的属性和方法：</p><ul><li><code>size</code> : <code>Map</code> 中成员的数目</li><li><code>get(key)</code> : 读取 <code>key</code> 对应的键值，如果找不到 <code>key</code> ，返回 <code>undefined</code>。</li><li><code>set(key, value)</code> : 设置键名 <code>key</code> 对应的键值为 <code>value</code>，然后返回该 <code>Map</code> 以便于链式调用</li><li><code>has(key)</code> : 判断 <code>Map</code> 中是否有 <code>key</code></li><li><code>delete(key)</code> : 删除键为 <code>key</code> 的键值对</li><li><code>clear()</code> : 清楚 <code>Map</code> 中所有成员</li></ul><p><code>Map</code> 的遍历方法同 <code>Set</code> 类似。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">map</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>([
    [<span style="color:#e6db74">&#39;F&#39;</span>, <span style="color:#e6db74">&#39;no&#39;</span>],
    [<span style="color:#e6db74">&#39;T&#39;</span>,  <span style="color:#e6db74">&#39;yes&#39;</span>],
]);

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">key</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">map</span>.<span style="color:#a6e22e">keys</span>()) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">key</span>);
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">map</span>.<span style="color:#a6e22e">values</span>()) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">item</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">map</span>.<span style="color:#a6e22e">entries</span>()) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">item</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">item</span>[<span style="color:#ae81ff">1</span>]);
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>] <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">map</span>.<span style="color:#a6e22e">entries</span>()) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>);
}
<span style="color:#75715e">// 等同于使用map.entries()
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>] <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">map</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>);
}
</code></pre></div><h2 id="map-同其他数据结构互转"><code>Map</code> 同其他数据结构互转</h2><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// map 转数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">map</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>()
  .<span style="color:#a6e22e">set</span>(<span style="color:#66d9ef">true</span>, <span style="color:#ae81ff">7</span>)
  .<span style="color:#a6e22e">set</span>({<span style="color:#a6e22e">foo</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>}, [<span style="color:#e6db74">&#39;abc&#39;</span>]);
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> [...<span style="color:#a6e22e">map</span>];

<span style="color:#75715e">// map 转对象
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">strMapToObj</span>(<span style="color:#a6e22e">strMap</span>) {
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">create</span>(<span style="color:#66d9ef">null</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">k</span>,<span style="color:#a6e22e">v</span>] <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">strMap</span>) {
        <span style="color:#a6e22e">obj</span>[<span style="color:#a6e22e">k</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">v</span>;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">obj</span>;
}

<span style="color:#75715e">// 对象转 map
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">objToStrMap</span>(<span style="color:#a6e22e">obj</span>) {
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">strMap</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>();
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">of</span> Object.<span style="color:#a6e22e">keys</span>(<span style="color:#a6e22e">obj</span>)) {
        <span style="color:#a6e22e">strMap</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">obj</span>[<span style="color:#a6e22e">k</span>]);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">strMap</span>;
}

<span style="color:#75715e">// Map 转为 JSON
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">strMapToJson</span>(<span style="color:#a6e22e">strMap</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">stringify</span>(<span style="color:#a6e22e">strMapToObj</span>(<span style="color:#a6e22e">strMap</span>));
}

<span style="color:#75715e">// JSON 转为 Map
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">jsonToStrMap</span>(<span style="color:#a6e22e">jsonStr</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">objToStrMap</span>(<span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">jsonStr</span>));
}
</code></pre></div><h1 id="代理----proxytarget-handler">代理 &ndash; <code>Proxy(target, handler)</code></h1><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面进行修改。</p><p><code>Proxy(target, handler)</code> 中的 <code>target</code> 是要代理的对象，而 <code>handler</code> 用来定制拦截行为。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// obj 代理了属性的读写操作
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Proxy({}, {
    <span style="color:#a6e22e">get</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">receiver</span>) {
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`getting </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">key</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">receiver</span>);
    },
    <span style="color:#a6e22e">set</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">receiver</span>) {
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`setting </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">key</span><span style="color:#e6db74">}</span><span style="color:#e6db74">!`</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">receiver</span>);
    }
});

<span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
<span style="color:#75715e">//  setting count!
</span><span style="color:#75715e"></span><span style="color:#f92672">++</span><span style="color:#a6e22e">obj</span>.<span style="color:#a6e22e">count</span>
<span style="color:#75715e">//  getting count!
</span><span style="color:#75715e">//  setting count!
</span><span style="color:#75715e">//  2
</span></code></pre></div><p>代理所支持的拦截对象如下，其中 <code>receiver</code> 参数是代理对象本身：</p><table><thead><tr><th align="left">操作</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>get(target, propKey, receiver)</code></td><td align="left">拦截对象属性的读取</td></tr><tr><td align="left"><code>set(target, propKey, value, receiver)</code></td><td align="left">拦截对象属性的赋值</td></tr><tr><td align="left"><code>has(target, propKey)</code></td><td align="left">拦截 <code>propKey in proxy</code> 的操作，返回一个布尔值。</td></tr><tr><td align="left"><code>deleteProperty(target, propKey)</code></td><td align="left">拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</td></tr><tr><td align="left"><code>ownKeys(target)</code></td><td align="left">拦截 <code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</td></tr><tr><td align="left"><code>getOwnPropertyDescriptor(target, propKey)</code></td><td align="left">返回属性的描述对象。</td></tr><tr><td align="left"><code>defineProperty(target, propKey, propDesc)</code></td><td align="left">拦截<code>Object.defineProperty(proxy, propKey, propDesc)</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</td></tr><tr><td align="left"><code>preventExtensions(target)</code></td><td align="left">拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</td></tr><tr><td align="left"><code>getPrototypeOf(target)</code></td><td align="left">拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</td></tr><tr><td align="left"><code>isExtensible(target)</code></td><td align="left">拦截 <code>Object.isExtensible(proxy)</code>，返回一个布尔值。</td></tr><tr><td align="left"><code>setPrototypeOf(target, proto)</code></td><td align="left">拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</td></tr><tr><td align="left"><code>apply(target, object, args)</code></td><td align="left">拦截 Proxy 实例作为函数调用的操作，比如 <code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</td></tr><tr><td align="left"><code>construct(target, args)</code></td><td align="left">拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code></td></tr></tbody></table><h2 id="代理对象的this指向问题">代理对象的this指向问题</h2><p>使用Proxy代理对象时，目标对象的 <code>this</code> 会指向Proxy对象。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">target</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">m</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span> () {
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">proxy</span>);
    }
};
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handler</span> <span style="color:#f92672">=</span> {};

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">proxy</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Proxy(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">handler</span>);

<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">m</span>() <span style="color:#75715e">// false
</span><span style="color:#75715e"></span><span style="color:#a6e22e">proxy</span>.<span style="color:#a6e22e">m</span>()  <span style="color:#75715e">// true
</span></code></pre></div><p>对于那些通过 <code>this</code> 才能访问的属性或方法，使用代理无法直接拿到，通过 <code>this</code> 绑定原生对象可以拿到。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">target</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Date(<span style="color:#e6db74">&#39;2015-01-01&#39;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handler</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">prop</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">prop</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;getDate&#39;</span>) {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">getDate</span>.<span style="color:#a6e22e">bind</span>(<span style="color:#a6e22e">target</span>);
        }
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">prop</span>);
    }
};
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">proxy</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Proxy(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">handler</span>);

<span style="color:#a6e22e">proxy</span>.<span style="color:#a6e22e">getDate</span>() <span style="color:#75715e">// 1
</span></code></pre></div><h2 id="reflect-类"><code>Reflect</code> 类</h2><p><code>Reflect</code> 类的方法同 <code>Proxy</code> 可以拦截的方法一一对应，这就让 <code>Proxy</code> 对象可以很方便地调用 <code>Reflect</code> 方法。</p><h1 id="promise"><code>Promise</code></h1><p><code>Promise</code> 是一个容器，保存着异步执行事件的结果。它是JavaScript异步编程的一种解决方案，比回调函数和事件更合理、更强大。 <code>Promise</code> 有两个特点：</p><ol><li>对象的状态不受外界影响，只有异步操作的结果可以影响对象的状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</li></ol><p><code>Promise(function(resolve, reject) {})</code> 的构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供。 <code>resolve</code> 函数的作用是，将 <code>Promise</code> 对象的状态从“未完成”变为“成功”，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code> 函数的作用是，将 <code>Promise</code> 对象的状态从“未完成”变为“失败”，并将异步操作报出的错误，作为参数传递出去。 <code>Promise</code> 实例生成以后，可以用 <code>then</code> 方法分别指定 <code>resolved</code> 状态和 <code>rejected</code> 状态的回调函数。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">promise</span>.<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">value</span>) {
    <span style="color:#75715e">// success
</span><span style="color:#75715e"></span>}, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">error</span>) {
    <span style="color:#75715e">// failure
</span><span style="color:#75715e"></span>});
</code></pre></div><p>下面是一个使用 <code>Promise</code> 完成ajax的例子</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">getJSON</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">url</span>) {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promise</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handler</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>() {
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">readyState</span> <span style="color:#f92672">!==</span> <span style="color:#ae81ff">4</span>) {
                <span style="color:#66d9ef">return</span> ;
            }
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">status</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">200</span>) {
                <span style="color:#a6e22e">resolve</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">response</span>);
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#a6e22e">reject</span>(<span style="color:#66d9ef">new</span> Error(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">statusText</span>));
            }
        };
        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">client</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">XMLHttpRequest</span>();
        <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">open</span>(<span style="color:#e6db74">&#34;GET&#34;</span>, <span style="color:#a6e22e">url</span>);
        <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">onreadystatechange</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">handler</span>;
        <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">responseType</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;json&#34;</span>;
        <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">setRequestHeader</span>(<span style="color:#e6db74">&#34;Accept&#34;</span>, <span style="color:#e6db74">&#34;application/json&#34;</span>);
        <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">send</span>();
    });

    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">promise</span>;
}

<span style="color:#a6e22e">getJSON</span>(<span style="color:#e6db74">&#34;/test.json&#34;</span>).<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">json</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">json</span>);
}, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">error</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Something happened: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">error</span>);
});
</code></pre></div><h2 id="promiseprototypethen"><code>Promise.prototype.then()</code></h2><p><code>Promise</code> 的 <code>then</code> 方法返回的是一个新的 <code>Promise</code> 实例，因此可以链式调用，这样就可以指定一组按照次序调用的回调函数：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">getJSON</span>(<span style="color:#e6db74">&#34;/post/1.json&#34;</span>).<span style="color:#a6e22e">then</span>(
    <span style="color:#a6e22e">post</span> =&gt; <span style="color:#a6e22e">getJSON</span>(<span style="color:#a6e22e">post</span>.<span style="color:#a6e22e">commentURL</span>)
).<span style="color:#a6e22e">then</span>(
    <span style="color:#a6e22e">comments</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;resolved: &#34;</span>, <span style="color:#a6e22e">comments</span>),
    <span style="color:#a6e22e">err</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;rejected: &#34;</span>, <span style="color:#a6e22e">err</span>)
);
</code></pre></div><h2 id="promiseprototypecatch"><code>Promise.prototype.catch()</code></h2><p><code>catch(rejection)</code> 方法等同于 <code>then(null, rejection)</code>，用于指定发生错误时的回调函数。 <code>Promise</code>对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 <code>catch</code> 语句捕获。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">getJSON</span>(<span style="color:#e6db74">&#39;/post/1.json&#39;</span>).<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">post</span>) {
     <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">getJSON</span>(<span style="color:#a6e22e">post</span>.<span style="color:#a6e22e">commentURL</span>);
}).<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">comments</span>) {
     <span style="color:#75715e">// some code
</span><span style="color:#75715e"></span>}).<span style="color:#66d9ef">catch</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">error</span>) {
    <span style="color:#75715e">// 处理前面三个Promise产生的错误
</span><span style="color:#75715e"></span>});
</code></pre></div><p>在 <code>resolve</code> 语句之后抛出的异常，不会被捕获。因为 <code>resolve</code> 之后，<code>Promise</code> 的状态已经发生改变，<code>Promise</code> 的状态一旦改变，就永久保持，不会再变了。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promise</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
    <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;ok&#39;</span>);
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#39;error&#39;</span>); <span style="color:#75715e">// 该异常不会被catch捕获
</span><span style="color:#75715e"></span>});

<span style="color:#a6e22e">promise</span>.<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">value</span>) {<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);})
    .<span style="color:#66d9ef">catch</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">err</span>) {<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">err</span>);})

</code></pre></div><p>推荐下面的第二种写法，因为 <code>catch</code> 中可以捕获 <code>then</code> 中的异常，<code>catch</code> 方法返回的是一个新的 <code>Promise</code> 对象，因此还可以继续调用 <code>Promise</code> 的方法。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// bad
</span><span style="color:#75715e"></span><span style="color:#a6e22e">promise</span>.<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">data</span>) {
    <span style="color:#75715e">// success
</span><span style="color:#75715e"></span>  }, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">err</span>) {
    <span style="color:#75715e">// error
</span><span style="color:#75715e"></span>  });

<span style="color:#75715e">// good
</span><span style="color:#75715e"></span><span style="color:#a6e22e">promise</span>.<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">data</span>) { <span style="color:#75715e">//cb
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// success
</span><span style="color:#75715e"></span>  })
  .<span style="color:#66d9ef">catch</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">err</span>) {
    <span style="color:#75715e">// error
</span><span style="color:#75715e"></span>  });
</code></pre></div><p><strong>如果没有<code>catch</code>方法处理回调函数中的异常，<code>Promise</code> 会打印出异常，但不会终止程序运行</strong>。</p><h2 id="promiseprototypefinally"><code>Promise.prototype.finally()</code></h2><p><code>finally()</code> 方式用于不管 Promise 对象最终状态如何，都会执行的操作。因为该方法不接受任何参数，因此其处理的事情应该同 Promise 无关。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">promise</span>.<span style="color:#a6e22e">then</span> (<span style="color:#a6e22e">result</span> =&gt; {})
    .<span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">err</span> =&gt; {})
    .<span style="color:#66d9ef">finally</span>(() =&gt; {})
</code></pre></div><h2 id="promiseprototypeallpromise"><code>Promise.prototype.all([...promise])</code></h2><p><code>all([...promise])</code> 接受具有 <code>Iterator</code> 接口的对象作为参数，每个元素都需要是 <code>Promise</code> 对象。如果不是，会先调用 <code>Promise.resolve()</code>来将其转换为 <code>Promise</code> 对象。 如果 <code>[...promise]</code> 中所有元素的状态都变为 <code>fulfilled</code>，那么 <code>all</code> 返回的 <code>Promise</code> 实例才会成为 <code>fulfilled</code>，只要有一个元素成为 <code>reject</code> 状态，那么该实例就会成为 <code>reject</code> 状态。</p><p>如果作为参数的 <code>Promise</code> 实例，自己定义了 <code>catch</code> 方法，那么它一旦被 <code>rejected</code>，并不会触发 <code>Promise.all()</code> 的 <code>catch</code> 方法。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
  <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;hello&#39;</span>);
}).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">result</span> =&gt; <span style="color:#a6e22e">result</span>)
    .<span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">e</span> =&gt; <span style="color:#a6e22e">e</span>);

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
  <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#39;报错了&#39;</span>);
}).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">result</span> =&gt; <span style="color:#a6e22e">result</span>)
    .<span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">e</span> =&gt; <span style="color:#a6e22e">e</span>);

Promise.<span style="color:#a6e22e">all</span>([<span style="color:#a6e22e">p1</span>, <span style="color:#a6e22e">p2</span>]).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">result</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">result</span>))
    .<span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">e</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">e</span>));
<span style="color:#75715e">// [&#34;hello&#34;, Error: 报错了]
</span></code></pre></div><h2 id="promiseprototyperace"><code>Promise.prototype.race()</code></h2><p><code>race([...promise])</code> 的参数同 <code>all()</code> 方法的参数一样，返回的也是 <code>Promise</code> 实例。参数中首先发生状态改变的元素会传递给该实例的回调函数。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> Promise.<span style="color:#a6e22e">race</span>([
    <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#39;/resource-that-may-take-a-while&#39;</span>),
    <span style="color:#66d9ef">new</span> Promise(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
        <span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">reject</span>(<span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#39;request timeout&#39;</span>)), <span style="color:#ae81ff">5000</span>)
    })
]);

<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>)
  .<span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>);
</code></pre></div><h2 id="promiseprototyperesolve"><code>Promise.prototype.resolve()</code></h2><p><code>resolve(object)</code> 将对象转换为 <code>Promise</code> 对象。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;foo&#39;</span>)
<span style="color:#75715e">// 等价于
</span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> Promise(<span style="color:#a6e22e">resolve</span> =&gt; <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;foo&#39;</span>))
</code></pre></div><h2 id="promiseprototypereject"><code>Promise.prototype.reject()</code></h2><p><code>reject()</code> 返回一个 <code>reject</code> 状态的 <code>Promise</code> 对象。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">thenable</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
        <span style="color:#a6e22e">reject</span>(<span style="color:#e6db74">&#39;出错了&#39;</span>);
    }
};

Promise.<span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">thenable</span>)
    .<span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">e</span> =&gt; {
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">e</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">thenable</span>)
    })
</code></pre></div><h1 id="generator-生成器函数"><code>Generator</code> 生成器函数</h1><p>Generator 函数是ES6提供的一种异步编程解决方案。可将其理解为封装了多个内部状态的状态机。执行 Generator 函数会返回一个遍历器对象，Generator 还是一个遍历器生成函数。 其形式如下，<code>function</code> 关键字后紧跟一个星号，使用<code>yield</code>(<code>yield</code> 表达式只能用在 <code>Generator</code> 函数中) 返回状态：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">myGenerator</span>() {
    <span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#39;hello&#39;</span>;
    <span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#39;world&#39;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;ending&#39;</span>;
}
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">generator</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">myGenerator</span>();
</code></pre></div><p>必须调用遍历器对象的 <code>next</code> 方法，使得指针移向下一个状态。也就是说，每次调用 <code>next</code> 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 <code>yield</code>表达式（或 <code>return</code> 语句）为止。</p><h2 id="next-方法"><code>next()</code> 方法</h2><p><code>next()</code> 可以有一个参数，该参数会被当作上一个yield表达式的返回值。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">f</span>() {
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#66d9ef">true</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">reset</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">i</span>;
        <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">reset</span>) { <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; }
    }
}

<span style="color:#75715e">// 构造一个迭代器 g 来控制这个生成器
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">f</span>();

<span style="color:#75715e">// 这里启动 f()，表示开始执行 f 函数中的内容
</span><span style="color:#75715e"></span><span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">next</span>() <span style="color:#75715e">// { value: 0, done: false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">next</span>() <span style="color:#75715e">// { value: 1, done: false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">next</span>(<span style="color:#66d9ef">true</span>) <span style="color:#75715e">// { value: 0, done: false }
</span></code></pre></div><h2 id="for--of-"><code>for .. of ..</code></h2><p>生成器函数可以使用 <code>for ... of ...</code> 来遍历。下面是一个利用 <code>Generator</code> 函数和 <code>for...of</code> 循环，实现斐波那契数列的例子。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">fibonacci</span>() {
    <span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">prev</span>, <span style="color:#a6e22e">curr</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">for</span> (;;) {
        [<span style="color:#a6e22e">prev</span>, <span style="color:#a6e22e">curr</span>] <span style="color:#f92672">=</span> [<span style="color:#a6e22e">curr</span>, <span style="color:#a6e22e">prev</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">curr</span>];
        <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">curr</span>;
    }
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">fibonacci</span>()) {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">n</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1000</span>) <span style="color:#66d9ef">break</span>;
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">n</span>);
}
</code></pre></div><p>利用 <code>for ... of ...</code> 循环可以遍历任意对象的方法，即使原生JavaScript不支持，也可以通过Generator函数给其加上相应的接口。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">objectEntries</span>(<span style="color:#a6e22e">obj</span>) {
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">propKeys</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">ownKeys</span>(<span style="color:#a6e22e">obj</span>);

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">propKey</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">propKeys</span>) {
        <span style="color:#66d9ef">yield</span> [<span style="color:#a6e22e">propKey</span>, <span style="color:#a6e22e">obj</span>[<span style="color:#a6e22e">propKey</span>]];
    }
}

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">jane</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">first</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Jane&#39;</span>, <span style="color:#a6e22e">last</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Doe&#39;</span> };

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>] <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">objectEntries</span>(<span style="color:#a6e22e">jane</span>)) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">key</span><span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
}
<span style="color:#75715e">// first: Jane
</span><span style="color:#75715e">// last: Doe
</span></code></pre></div><h2 id="generatorprototypethrow"><code>Generator.prototype.throw()</code></h2><p>Generator 的 <code>throw</code> 方法可以在函数体外抛出错误，然后在 Generator 函数中捕获。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> () {
    <span style="color:#66d9ef">try</span> {
        <span style="color:#66d9ef">yield</span>;
    } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">e</span>) {
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;内部捕获&#39;</span>, <span style="color:#a6e22e">e</span>);
    }
};

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">g</span>();
<span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">next</span>();

<span style="color:#75715e">// 第一个错误被 g 函数体内的 catch 捕获
</span><span style="color:#75715e">// 因为catch已经执行，所以第二个错误被函数体外的 catch 捕获
</span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span> {
    <span style="color:#a6e22e">i</span>.<span style="color:#66d9ef">throw</span>(<span style="color:#e6db74">&#39;a&#39;</span>);
    <span style="color:#a6e22e">i</span>.<span style="color:#66d9ef">throw</span>(<span style="color:#e6db74">&#39;b&#39;</span>);
} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">e</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;外部捕获&#39;</span>, <span style="color:#a6e22e">e</span>);
}
<span style="color:#75715e">// 内部捕获 a
</span><span style="color:#75715e">// 外部捕获 b
</span></code></pre></div><p><code>throw</code> 被捕获之后，生成器会自动执行一次 <code>next</code>，返回下一次的 <code>yield</code>。 如果 <code>throw</code> 没有被捕获，就不会再执行下去了。如果此后还调用 <code>next</code>，将会返回一个 <code>{value: undefined, done: true}</code> 的值。</p><h2 id="generatorprototypereturn"><code>Generator.prototype.return()</code></h2><p><code>return(value)</code> 方法可以返回给定的值，并且终结遍历器 <code>Generator</code> 函数。若不提供 <code>value</code> 参数，则返回 <code>undefined</code>；若函数内有 <code>try ... finally</code>，那么 <code>return</code> 方法会推迟到 <code>finally</code> 代码块执行完再执行。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">numbers</span> () {
    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">try</span> {
        <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">3</span>;
    } <span style="color:#66d9ef">finally</span> {
        <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">4</span>;
        <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">5</span>;
    }
    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">6</span>;
}
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">numbers</span>();
<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">next</span>() <span style="color:#75715e">// { value: 1, done: false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">next</span>() <span style="color:#75715e">// { value: 2, done: false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">g</span>.<span style="color:#66d9ef">return</span>(<span style="color:#ae81ff">7</span>) <span style="color:#75715e">// { value: 4, done: false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">next</span>() <span style="color:#75715e">// { value: 5, done: false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">next</span>() <span style="color:#75715e">// { value: 7, done: true }
</span></code></pre></div><p>如果生成器中有无限循环，也可以通过 <code>break</code> 来终止生成器，对于释放生成器中的资源很有用。+</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">something</span>() {
    <span style="color:#66d9ef">try</span> {
        <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">nextVal</span>;
        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">nextVal</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span>) {
                <span style="color:#a6e22e">nextVal</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#a6e22e">nextVal</span> <span style="color:#f92672">=</span> (<span style="color:#ae81ff">3</span><span style="color:#f92672">*</span><span style="color:#a6e22e">nextVal</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">6</span>;
            }
            <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">next</span>;
        }
    } <span style="color:#66d9ef">finally</span> {
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;cleaning up!&#34;</span>);
    }
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">something</span>()) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">v</span>);
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">v</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">5</span>) {
        <span style="color:#66d9ef">break</span>;
    }
}
<span style="color:#75715e">/**
</span><span style="color:#75715e">1
</span><span style="color:#75715e">9
</span><span style="color:#75715e">33
</span><span style="color:#75715e">105
</span><span style="color:#75715e">321
</span><span style="color:#75715e">969
</span><span style="color:#75715e">cleaning up!
</span><span style="color:#75715e">*/</span>
</code></pre></div><h2 id="yield-表达式"><code>yield*</code> 表达式</h2><p>如果在 Generator 函数内部调用另外一个 Generator 函数，默认情况下是没有效果的，这就需要用到 <code>yield*</code> 表达式。 <code>yield*</code> 后接的是遍历器对象，返回的是遍历器内部的对象。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">inner</span>() {
    <span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#39;hello&#39;</span>
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;world!&#39;</span>
}
<span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">outer</span>() {
    <span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#39;open&#39;</span>
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">inner</span>()
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;inner\&#39;s result: &#39;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">result</span>)
    <span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#39;close&#39;</span>
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;return&#39;</span>
}

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">gen</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">outer</span>()
<span style="color:#a6e22e">gen</span>.<span style="color:#a6e22e">next</span>().<span style="color:#a6e22e">value</span> <span style="color:#75715e">// &#34;open&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">gen</span>.<span style="color:#a6e22e">next</span>().<span style="color:#a6e22e">value</span> <span style="color:#75715e">// &#34;hello&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">gen</span>.<span style="color:#a6e22e">next</span>().<span style="color:#a6e22e">value</span> <span style="color:#75715e">// &#34;close&#34;
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 也可以用 for ... of 遍历，但是 for ... of 不会遍历 return 后的值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">gen2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">outer</span>()
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">g</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">gen2</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">g</span>);
}
<span style="color:#75715e">// &#34;open&#34;
</span><span style="color:#75715e">// &#34;hello&#34;
</span><span style="color:#75715e">// &#34;inner&#39;s result: world!&#34;
</span><span style="color:#75715e">// &#34;close&#34;
</span></code></pre></div><p><code>yield*</code> 后跟数组的话，因为数组支持遍历器，所以会遍历数组成员。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">gen</span>() {
    <span style="color:#66d9ef">yield</span><span style="color:#f92672">*</span> [<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>];
}

<span style="color:#a6e22e">gen</span>.<span style="color:#a6e22e">next</span>().<span style="color:#a6e22e">value</span> <span style="color:#75715e">// &#34;a&#34;
</span></code></pre></div><p>可以使用<code>yield*</code> 很方便地取出嵌套数组的所有成员：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">iterTree</span>(<span style="color:#a6e22e">tree</span>) {
    <span style="color:#66d9ef">if</span> (Array.<span style="color:#a6e22e">isArray</span>(<span style="color:#a6e22e">tree</span>)) {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">tree</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">yield</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">iterTree</span>(<span style="color:#a6e22e">tree</span>[<span style="color:#a6e22e">i</span>]);
        }
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">tree</span>;
    }
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">tree</span> <span style="color:#f92672">=</span> [ <span style="color:#e6db74">&#39;a&#39;</span>, [<span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>], [<span style="color:#e6db74">&#39;d&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>] ];

<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">iterTree</span>(<span style="color:#a6e22e">tree</span>)) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">x</span>);
}
</code></pre></div><h2 id="对象中的-generator-函数">对象中的 Generator 函数</h2><p>在对象中使用如下方式编写 Generator 函数：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 简写方式如下
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {
    <span style="color:#f92672">*</span> <span style="color:#a6e22e">myGeneratorMethod</span>() {
        <span style="color:#75715e">// ···
</span><span style="color:#75715e"></span>    }
};
<span style="color:#75715e">// 完整方式
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">myGeneratorMethod</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> () {
        <span style="color:#75715e">// ···
</span><span style="color:#75715e"></span>    }
};
</code></pre></div><h2 id="generator-的应用">Generator 的应用</h2><ol><li>Generator 将异步操作转换成同步操作表达.</li></ol><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 将 Ajax 请求用同步的方式表达
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">request</span>(<span style="color:#e6db74">&#34;http://some.url&#34;</span>);
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">resp</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">result</span>);
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">value</span>);
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">request</span>(<span style="color:#a6e22e">url</span>) {
    <span style="color:#a6e22e">makeAjaxCall</span>(<span style="color:#a6e22e">url</span>, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">response</span>){
        <span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">response</span>);
    });
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">it</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">main</span>();
<span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>();
</code></pre></div><ol start="2"><li>控制流程管理：如果有一个耗时的同步操作，写成多个回调函数：</li></ol><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">step1</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">value1</span>) {
    <span style="color:#a6e22e">step2</span>(<span style="color:#a6e22e">value1</span>, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">value2</span>) {
        <span style="color:#a6e22e">step3</span>(<span style="color:#a6e22e">value2</span>, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">value3</span>) {
        <span style="color:#a6e22e">step4</span>(<span style="color:#a6e22e">value3</span>, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">value4</span>) {
            <span style="color:#75715e">// Do something with value4
</span><span style="color:#75715e"></span>        });
        });
    });
});

<span style="color:#75715e">// 将其改写成Promise对象
</span><span style="color:#75715e"></span>Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">step1</span>)
    .<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">step2</span>)
    .<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">step3</span>)
    .<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">step4</span>)
    .<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">value4</span>) {
        <span style="color:#75715e">// Do something with value4
</span><span style="color:#75715e"></span>    }, <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">error</span>) {
        <span style="color:#75715e">// Handle any error from step1 through step4
</span><span style="color:#75715e"></span>    })
    .<span style="color:#a6e22e">done</span>();

<span style="color:#75715e">// 写成生成器的形式
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">steps</span> <span style="color:#f92672">=</span> [<span style="color:#a6e22e">step1</span>, <span style="color:#a6e22e">step2</span>, <span style="color:#a6e22e">step3</span>];

<span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">iterateSteps</span>(<span style="color:#a6e22e">steps</span>){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">steps</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">step</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">steps</span>[<span style="color:#a6e22e">i</span>];
        <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">step</span>();
    }
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">step</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">iterateJobs</span>(<span style="color:#a6e22e">jobs</span>)){
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">step</span>.<span style="color:#a6e22e">id</span>);
}
</code></pre></div><ol start="3"><li>部署 Iterator 接口 利用 Generator 函数，可以在任意对象上部署 Iterator 接口。</li></ol><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">iterEntries</span>(<span style="color:#a6e22e">obj</span>) {
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">keys</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">keys</span>(<span style="color:#a6e22e">obj</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">keys</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">keys</span>[<span style="color:#a6e22e">i</span>];
        <span style="color:#66d9ef">yield</span> [<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">obj</span>[<span style="color:#a6e22e">key</span>]];
  }
}

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">myObj</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">foo</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">bar</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">7</span> };

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> [<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>] <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">iterEntries</span>(<span style="color:#a6e22e">myObj</span>)) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>);
}
</code></pre></div><h1 id="异步的-generator">异步的 Generator</h1><p><code>yield</code> 命令会暂停当前函数的执行，让出控制权，等再次获取到控制权之后继续执行。因此可以将异步操作封装到一个Generator函数中，还可以通过 <code>next</code> 方法向异步操作中传递参数，通过 <code>throw</code> 方法还可以捕获程序外部抛出的异常信息。 我们可以用如下方式对异步任务进行封装：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">fetch</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;node-fetch&#39;</span>);

<span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">gen</span>(){
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">url</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;https://api.github.com/users/github&#39;</span>;
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#a6e22e">url</span>);
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">bio</span>);
}

<span style="color:#75715e">// 调用方式如下
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">gen</span>();
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">next</span>();

<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">value</span>.<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">data</span>){
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">json</span>();
}).<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">data</span>){
    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">data</span>);
});
</code></pre></div><p>从上面代码可以看到，用 Generator 函数封装异步操作很简洁明了，但是对流程管理却不很擅长。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) {
    <span style="color:#a6e22e">ajax</span>(<span style="color:#e6db74">`http://som.url/?x=</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&amp;y=</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">y</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>, <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">data</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">err</span>) {
            <span style="color:#75715e">// 向 *main() 抛出一个错误
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">it</span>.<span style="color:#66d9ef">throw</span>(<span style="color:#a6e22e">err</span>);
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#75715e">// 用收到的 data 恢复 *main()
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">it</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">data</span>);
        }
    })
}

<span style="color:#66d9ef">function</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">main</span> () {
    <span style="color:#66d9ef">try</span> {
        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">text</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">foo</span>(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">31</span>);
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">text</span>);
    } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">err</span>) {
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">err</span>);
    }
}
</code></pre></div><h2 id="trunk-函数">Trunk 函数</h2><p>编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。它是“传名调用”的一种实现策略，用来替换某个表达式。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">m</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
}

<span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>);

<span style="color:#75715e">// 等同于
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">thunk</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> () {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>;
};

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">thunk</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">thunk</span>() <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
}
</code></pre></div><p>但是 JavaScript 中的 Trunk 函数不是表达式，而是将多参数函数替换成一个只接受回调函数作为参数的单参数函数。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 正常版本的readFile（多参数版本）
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fs</span>.<span style="color:#a6e22e">readFile</span>(<span style="color:#a6e22e">fileName</span>, <span style="color:#a6e22e">callback</span>);

<span style="color:#75715e">// Thunk版本的readFile（单参数版本）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">Thunk</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">fileName</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">callback</span>) {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fs</span>.<span style="color:#a6e22e">readFile</span>(<span style="color:#a6e22e">fileName</span>, <span style="color:#a6e22e">callback</span>);
    };
};

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">readFileThunk</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Thunk</span>(<span style="color:#a6e22e">fileName</span>);
<span style="color:#a6e22e">readFileThunk</span>(<span style="color:#a6e22e">callback</span>);
</code></pre></div><p>只要有回调函数作为参数的函数，就能写成Thunk函数的形式，下面是一个简单的函数转换器：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">Thunk</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">fn</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span> () {
        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">args</span> <span style="color:#f92672">=</span> Array.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">slice</span>.<span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">arguments</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">callback</span>) {
            <span style="color:#a6e22e">args</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">callback</span>);
            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fn</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#66d9ef">this</span>, <span style="color:#a6e22e">args</span>);
        }
    }
}

<span style="color:#75715e">// ES6
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Thunk</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">fn</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span>(...<span style="color:#a6e22e">args</span>) {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">callback</span>) {
            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fn</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">this</span>, ...<span style="color:#a6e22e">args</span>, <span style="color:#a6e22e">callback</span>);
        }
    }
}
</code></pre></div><h2 id="使用-thunkify-模块">使用 <code>Thunkify</code> 模块</h2><p>生产环境中，推荐使用 Thunkify 模块。安装 <code>npm install thunkify</code>，使用方式如下：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">thunkify</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;thunkify&#39;</span>);
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">fs</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;fs&#39;</span>);
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">read</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">thunkify</span>(<span style="color:#a6e22e">fs</span>.<span style="color:#a6e22e">readFile</span>);
<span style="color:#a6e22e">read</span>(<span style="color:#e6db74">&#39;file&#39;</span>)(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">str</span>){
    <span style="color:#75715e">// do something
</span><span style="color:#75715e"></span>})
</code></pre></div><h2 id="generator-流程管理">Generator 流程管理</h2><p>使用 Thunk 函数可以将 Generator 函数自执行。下面就是一个基于 Thunk 函数的 Generator 执行器。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">run</span>(<span style="color:#a6e22e">fn</span>) {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">gen</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fn</span>();

    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">data</span>) {
        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">gen</span>.<span style="color:#a6e22e">next</span>(<span style="color:#a6e22e">data</span>);
        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">done</span>) <span style="color:#66d9ef">return</span>;
        <span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">value</span>(<span style="color:#a6e22e">next</span>);
    }

    <span style="color:#a6e22e">next</span>();
}

<span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">g</span>() {
  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}

<span style="color:#a6e22e">run</span>(<span style="color:#a6e22e">g</span>);
</code></pre></div><p>有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入 <code>run</code> 函数即可。当然，前提是每一个异步操作都是 Thunk 函数。</p><h1 id="async-函数"><code>async</code> 函数</h1><p><code>async</code> 函数就是 Generator 生成器的语法糖。 对于读取文件的操作：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 使用 Generator
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fs</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;fs&#39;</span>);

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">readFile</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">fileName</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise(<span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
        <span style="color:#a6e22e">fs</span>.<span style="color:#a6e22e">readFile</span>(<span style="color:#a6e22e">fileName</span>, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">error</span>, <span style="color:#a6e22e">data</span>) {
            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">error</span>) <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">reject</span>(<span style="color:#a6e22e">error</span>);
            <span style="color:#a6e22e">resolve</span>(<span style="color:#a6e22e">data</span>);
        });
    });
};

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">gen</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> () {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">f1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">readFile</span>(<span style="color:#e6db74">&#39;/etc/fstab&#39;</span>);
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">f2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">readFile</span>(<span style="color:#e6db74">&#39;/etc/shells&#39;</span>);
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">f1</span>.<span style="color:#a6e22e">toString</span>());
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">f2</span>.<span style="color:#a6e22e">toString</span>());
};

<span style="color:#75715e">// 使用 async 函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">asyncReadFile</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">async</span> <span style="color:#66d9ef">function</span> () {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">f1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">await</span> <span style="color:#a6e22e">readFile</span>(<span style="color:#e6db74">&#39;/etc/fstab&#39;</span>);
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">f2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">await</span> <span style="color:#a6e22e">readFile</span>(<span style="color:#e6db74">&#39;/etc/shells&#39;</span>);
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">f1</span>.<span style="color:#a6e22e">toString</span>());
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">f2</span>.<span style="color:#a6e22e">toString</span>());
};
</code></pre></div><p>比较发现：<code>async</code> 函数就是将 Generator 函数的星号（<code>*</code>）替换成 <code>async</code>，将<code>yield</code>替换成<code>await</code>. <code>await</code> 相比于 Generator 有如下优势：</p><ol><li>内置执行器。Generator 函数的自执行必须靠执行器，而 <code>async</code> 函数不用</li><li>更好的语义。<code>async</code> 和 <code>await</code> 比 <code>*</code> 和 <code>yield</code> 有更好的语义</li><li>返回值是 Promise 对象，可以用 <code>then</code> 方法添加回调函数</li></ol><p><strong>函数前面的 <code>async</code> 关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个 Promise 对象。</strong> <strong><code>await</code>会等待 <code>async</code> 函数中的 <code>Promise</code> 执行完毕.</strong></p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">timeout</span>(<span style="color:#a6e22e">ms</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>) =&gt; {
        <span style="color:#a6e22e">setTimeout</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">ms</span>);
    });
}

<span style="color:#a6e22e">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">asyncPrint</span>(<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">ms</span>) {
    <span style="color:#a6e22e">await</span> <span style="color:#a6e22e">timeout</span>(<span style="color:#a6e22e">ms</span>);
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
}

<span style="color:#a6e22e">asyncPrint</span>(<span style="color:#e6db74">&#39;hello world&#39;</span>, <span style="color:#ae81ff">50</span>);
</code></pre></div><h2 id="使用-1">使用</h2><p><code>async</code> 函数返回的是 Promise 对象，函数 <code>return</code> 返回的值成为 <code>then</code> 方法的回调函数。 如果 <code>async</code> 函数中抛出了错误，那么返回的 Promise 处于 reject 状态，会被 Promise 的 <code>catch</code> 方法捕获。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>() {
    <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#39;出错了&#39;</span>);
}

<span style="color:#a6e22e">f</span>().<span style="color:#a6e22e">then</span>(
    <span style="color:#a6e22e">v</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">v</span>),
    <span style="color:#a6e22e">e</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">e</span>)
)
<span style="color:#75715e">// Error: 出错了
</span></code></pre></div><p>只有 <code>async</code> 函数内部的异步操作执行完，Promise 对象才会发出变化，执行then方法指定的回调函数。</p><h2 id="async-错误处理"><code>async</code> 错误处理</h2><p>在 <code>async</code> 函数中，如果有一个 <code>await</code> 后的 Promise 对象变为 reject 状态，那么后续的代码就不会再执行。如果不想因该语句影响后续的执行，那么就需要处理异常：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>() {
  <span style="color:#66d9ef">try</span> {
    <span style="color:#a6e22e">await</span> Promise.<span style="color:#a6e22e">reject</span>(<span style="color:#e6db74">&#39;出错了&#39;</span>);
  } <span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">e</span>) { }
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">await</span> Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;hello world&#39;</span>);
}

<span style="color:#a6e22e">f</span>().<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">v</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">v</span>))

<span style="color:#75715e">// 或者使用 Promise 对象的 catch
</span><span style="color:#75715e"></span><span style="color:#a6e22e">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f1</span>() {
    <span style="color:#a6e22e">await</span> Promise.<span style="color:#a6e22e">reject</span>(<span style="color:#e6db74">&#39;出错了&#39;</span>)
            .<span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">e</span> =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">e</span>));
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">await</span> Promise.<span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;hello world&#39;</span>);
}
</code></pre></div><p>还可以使用 <code>try ... catch</code> 实现多次尝试</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">superagent</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;superagent&#39;</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">NUM_RETRIES</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;

<span style="color:#a6e22e">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">test</span>() {
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">NUM_RETRIES</span>; <span style="color:#f92672">++</span><span style="color:#a6e22e">i</span>) {
        <span style="color:#66d9ef">try</span> {
            <span style="color:#a6e22e">await</span> <span style="color:#a6e22e">superagent</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#39;http://google.com/this-throws-an-error&#39;</span>);
            <span style="color:#66d9ef">break</span>; <span style="color:#75715e">// 没有异常，跳出循环
</span><span style="color:#75715e"></span>        } <span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">err</span>) {}
    }
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">i</span>); <span style="color:#75715e">// 3
</span><span style="color:#75715e"></span>}

<span style="color:#a6e22e">test</span>();
</code></pre></div><p>如果多个 <code>await</code> 后的操作相互之间不存在依赖关系，那么可以使用如下方式让其同时触发</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">dbFuc</span>(<span style="color:#a6e22e">db</span>) {
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">docs</span> <span style="color:#f92672">=</span> [{}, {}, {}];
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">promises</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">docs</span>.<span style="color:#a6e22e">map</span>((<span style="color:#a6e22e">doc</span>) =&gt; <span style="color:#a6e22e">db</span>.<span style="color:#a6e22e">post</span>(<span style="color:#a6e22e">doc</span>));

    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">results</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">await</span> Promise.<span style="color:#a6e22e">all</span>(<span style="color:#a6e22e">promises</span>);
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">results</span>);
}
</code></pre></div><h1 id="class-的基本语法">Class 的基本语法</h1><p>ES6 的 Class 类只是一个语法糖，它的绝大多数功能 ES5 都能实现，它只是让对象原型的写法更加清晰、更像面向对象编程的语法。 类和模块的内部，默认就是严格模式，所以不需要使用 <code>use strict</code> 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p><h2 id="构造器方法">构造器方法</h2><p><code>constructor</code> 方法是类的默认方法，通过 <code>new</code> 命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。<code>constructor</code> 默认返回实例对象，而且类必须使用 <code>new</code> 调用，否则会报错。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Bar</span> {
    <span style="color:#a6e22e">constructor</span> () {}
}

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">bar</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Bar</span>();

<span style="color:#a6e22e">Bar</span>(); <span style="color:#75715e">// 报错
</span></code></pre></div><h2 id="实例对象">实例对象</h2><p>实例的属性除非显示地定义在其自身（<code>this</code> 对象），否则都定义在原型（<code>prototype</code>）上。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">//定义类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span> {
    <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) {
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>;
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span>;
    }

    <span style="color:#a6e22e">toString</span>() {
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;, &#39;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;)&#39;</span>;
    }
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">point</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Point</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);

<span style="color:#a6e22e">point</span>.<span style="color:#a6e22e">toString</span>() <span style="color:#75715e">// (2, 3)
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">point</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#e6db74">&#39;x&#39;</span>) <span style="color:#75715e">// true
</span><span style="color:#75715e"></span><span style="color:#a6e22e">point</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#e6db74">&#39;y&#39;</span>) <span style="color:#75715e">// true
</span><span style="color:#75715e"></span><span style="color:#a6e22e">point</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#e6db74">&#39;toString&#39;</span>) <span style="color:#75715e">// false
</span><span style="color:#75715e"></span><span style="color:#a6e22e">point</span>.<span style="color:#a6e22e">__proto__</span>.<span style="color:#a6e22e">hasOwnProperty</span>(<span style="color:#e6db74">&#39;toString&#39;</span>) <span style="color:#75715e">// true
</span></code></pre></div><h2 id="class-表达式">class 表达式</h2><p>JavaScript 中的 class 也可以写成表达式的形式：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 类名是 MyClass，Me 只能在 class 内部可以使用，相当于 this
</span><span style="color:#75715e">// 如果在 class 中不使用 Me，可以将其省略
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">MyClass</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Me</span> {
    <span style="color:#a6e22e">getClassName</span>() {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Me</span>.<span style="color:#a6e22e">name</span>;
    }
}

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">me</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Me</span>(); <span style="color:#75715e">// 会报错： ReferenceError: Me is not defined
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 立即执行类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">you</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">class</span> {
    <span style="color:#a6e22e">constructor</span> (<span style="color:#a6e22e">name</span>) {
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">name</span>;
    }
    <span style="color:#a6e22e">getName</span>() {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>;
    }
}(<span style="color:#e6db74">&#39;name&#39;</span>);
<span style="color:#a6e22e">you</span>.<span style="color:#a6e22e">getName</span>();
</code></pre></div><p><strong>类不存在变量提升</strong></p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Foo</span>(); <span style="color:#75715e">// ReferenceError
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span> {}
</code></pre></div><h2 id="getter-和-setter-方法">getter 和 setter 方法</h2><p>在类的内部可以使用 <code>get</code> 和 <code>set</code> 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
    <span style="color:#a6e22e">constructor</span>() {
        <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    }

    <span style="color:#75715e">// this.value 中的 value 如果同 get value() 的名字一致，就会 RangeError: Maximum call stack size exceeded
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">prop</span>() {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pro</span>;
    }
    <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">prop</span>(<span style="color:#a6e22e">value</span>) {
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">pro</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
    }
}

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">inst</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MyClass</span>();

<span style="color:#a6e22e">inst</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">123</span>;
<span style="color:#a6e22e">inst</span>.<span style="color:#a6e22e">prop</span>  <span style="color:#75715e">// &#39;123&#39;
</span></code></pre></div><h2 id="静态方法">静态方法</h2><p>如果在一个方法前，加上 <code>static</code> 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span> {
    <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">bar</span> () {
        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">baz</span>();
    }
    <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">baz</span> () {
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;hello&#39;</span>);
    }
    <span style="color:#75715e">// 静态方法可以和非静态方法重名
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">baz</span> () {
        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;world&#39;</span>);
    }
}

<span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">bar</span>() <span style="color:#75715e">// hello
</span></code></pre></div><p>静态方法中的 <code>this</code> 关键字，指向的是类，而不是实例。 在实例上调用静态方法，会抛出不存在该方法的错误。</p><p>父类的静态方法，也可以被子类继承。</p><h2 id="class-的静态属性和实例属性">class 的静态属性和实例属性</h2><p>静态属性是类的属性，而不是实例属性。对于静态属性只有如下方式可以实现，因为ES6明确规定，Class内部只有静态方法，没有静态属性：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span> {}
<span style="color:#75715e">// 静态属性 prop
</span><span style="color:#75715e"></span><span style="color:#a6e22e">Foo</span>.<span style="color:#a6e22e">prop</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</code></pre></div><h2 id="newtarget-属性"><code>new.target</code> 属性</h2><p><code>new.target</code> 属性一般用在构造函数中，返回 <code>new</code> 命令作用的那个构造函数。如果构造函数不是通过 <code>new</code> 命令调用的，<code>new.target</code> 会返回 <code>undefined</code>.</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span> {
    <span style="color:#a6e22e">constructor</span> (<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">new</span>.<span style="color:#a6e22e">target</span> <span style="color:#f92672">!==</span> <span style="color:#66d9ef">undefined</span>) {
             <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>;
            <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">y</span>;
            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">new</span>.<span style="color:#a6e22e">target</span>); <span style="color:#75715e">// [Function: Point]
</span><span style="color:#75715e"></span>        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#39;must use new to instance&#39;</span>);
        }
    }
}
</code></pre></div><h1 id="类继承">类继承</h1><p>Class 可以通过 <code>extends</code> 关键字实现继承：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rectangle</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Point</span> {
    <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">tangle</span>) {
        <span style="color:#66d9ef">super</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>); <span style="color:#75715e">// 调用父类的构造器
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">tagnle</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">tangle</span>;
    }

    <span style="color:#a6e22e">toString</span> () {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">tangle</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">+</span> <span style="color:#66d9ef">super</span>.<span style="color:#a6e22e">toString</span>();
    }
}
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Rectangle</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">30</span>);
</code></pre></div><p><strong>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，这是因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，而后对其加工。若不调用<code>super</code>方法，那么子类就没有<code>this</code>对象</strong></p><p><strong>子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，因为子类实例的构建是基于对父类实例加工，只有<code>super</code>方法才能返回父类实例。</strong></p><h2 id="类的prototype属性和__proto__属性">类的<code>prototype</code>属性和<code>__proto__</code>属性</h2><p>ES5中，每一个对象都有 <code>__proto__</code>属性，指向对应的构造函数 <code>prototype</code> 属性。<code>class</code> 作为语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性。</p><ol><li>子类的 <code>__proto__</code> 属性，表示构造函数的继承，总是指向父类</li><li>子类的 <code>prototype</code> 属性的 <code>__proto__</code> 属性，表示方法的继承，总是指向父类的 <code>prototype</code> 属性。</li></ol><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">A</span> {}

<span style="color:#a6e22e">B</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">A</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span><span style="color:#a6e22e">B</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">A</span>.<span style="color:#a6e22e">prototype</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 继承实现模式
</span><span style="color:#75715e">// B 的实例继承 A 的实例
</span><span style="color:#75715e"></span>Object.<span style="color:#a6e22e">setPrototypeOf</span>(<span style="color:#a6e22e">B</span>.<span style="color:#a6e22e">prototype</span>, <span style="color:#a6e22e">A</span>.<span style="color:#a6e22e">prototype</span>);
<span style="color:#75715e">// B 继承 A 的静态属性
</span><span style="color:#75715e"></span>Object.<span style="color:#a6e22e">setPrototypeOf</span>(<span style="color:#a6e22e">B</span>, <span style="color:#a6e22e">A</span>);
</code></pre></div><h2 id="继承目标">继承目标</h2><p><code>extends</code> 后可以跟许多类型，只要该类型是有 <code>prototype</code> 属性的函数。 有三种特殊情况：</p><ol><li><p>子类继承 <code>Object</code> 类</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> <span style="color:#66d9ef">extends</span> Object {}
<span style="color:#a6e22e">A</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> Object <span style="color:#75715e">// true
</span><span style="color:#75715e"></span><span style="color:#a6e22e">A</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> Object.<span style="color:#a6e22e">prototype</span> <span style="color:#75715e">// true
</span></code></pre></div></li><li><p>不继承任何类</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {}
<span style="color:#a6e22e">A</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> Function.<span style="color:#a6e22e">prototype</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span><span style="color:#a6e22e">A</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> Object.<span style="color:#a6e22e">prototype</span> <span style="color:#75715e">// true
</span></code></pre></div></li><li><p>子类继承 <code>null</code></p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> <span style="color:#66d9ef">extends</span> <span style="color:#66d9ef">null</span> {}
<span style="color:#a6e22e">A</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> Function.<span style="color:#a6e22e">prototype</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span><span style="color:#a6e22e">A</span>.<span style="color:#a6e22e">prototype</span>.<span style="color:#a6e22e">__proto__</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">undefined</span> <span style="color:#75715e">// true
</span></code></pre></div></li></ol><h2 id="mixin-模式实现">Mixin 模式实现</h2><p>Mixin 指多个对象合成一个新对象，新对象具有各个组成成员的接口。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">mix</span>(...<span style="color:#a6e22e">mixins</span>) {
    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Mix</span> {}

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mixin</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">mixins</span>) {
        <span style="color:#a6e22e">copyProperties</span>(<span style="color:#a6e22e">Mix</span>, <span style="color:#a6e22e">mixin</span>);
        <span style="color:#a6e22e">copyProperties</span>(<span style="color:#a6e22e">Mix</span>.<span style="color:#a6e22e">prototype</span>, <span style="color:#a6e22e">mixin</span>.<span style="color:#a6e22e">prototype</span>)
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Mix</span>;
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">copyProperties</span> (<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">source</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">key</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">Reflect</span>.<span style="color:#a6e22e">ownKeys</span>(<span style="color:#a6e22e">source</span>)) {
        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">key</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#39;constructor&#39;</span>
            <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#39;prototype&#39;</span>
            <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#39;name&#39;</span>
        ) {
            <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">desc</span> <span style="color:#f92672">=</span> Object.<span style="color:#a6e22e">getOwnPropertyDescriptor</span>(<span style="color:#a6e22e">source</span>, <span style="color:#a6e22e">key</span>);
            <span style="color:#a6e22e">Obejct</span>.<span style="color:#a6e22e">defineProperty</span>(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">desc</span>);
        }
    }
}
</code></pre></div><h1 id="module-语法">Module 语法</h1><p>模块功能主要由两个命令构成：<code>export</code> 和 <code>import</code>。<code>export</code> 命令用于规定该模块的对外接口，<code>import</code> 命令用于引入其他模块的功能。</p><p>该功能nodejs可能不支持，需要使用 babel 才能正常运行：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-s" data-lang="s"><span style="color:#75715e"># 全局安装</span>
npm install babel<span style="color:#f92672">-</span>cli <span style="color:#f92672">-</span>g
<span style="color:#75715e"># 本地安装</span>
npm install babel<span style="color:#f92672">-</span>cli <span style="color:#f92672">--</span>save

<span style="color:#75715e"># 使用</span>
babel<span style="color:#f92672">-</span>node main.js
</code></pre></div><h2 id="export"><code>export</code></h2><p>一个模块就是一个独立的文件，文件内部的所有变量，外部无法获取。使用 <code>export</code> 关键字可以将希望外部能够获取的变量输出：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// example.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">firstName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Michael&#39;</span>
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Jackson&#39;</span>

<span style="color:#75715e">// 建议书写方式
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">firstName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Michael&#39;</span>
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Jackson&#39;</span> 

<span style="color:#66d9ef">export</span> {<span style="color:#a6e22e">firsName</span>, <span style="color:#a6e22e">lastName</span>}
</code></pre></div><p><code>export</code> 还可以输出函数或者类</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// example.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f1</span> () {}
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f2</span> () {}

<span style="color:#66d9ef">export</span> {
    <span style="color:#a6e22e">f1</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">fun1</span>,
    <span style="color:#a6e22e">f2</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">fun2</span>,
    <span style="color:#a6e22e">f2</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">fun2Alias</span>
}
</code></pre></div><h2 id="import"><code>import</code></h2><p>使用 <code>export</code> 命令定义模块对外接口后，就可以用 <code>import</code> 来加载该模块。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">firstName</span>, <span style="color:#a6e22e">lastName</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./example&#39;</span>;
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">firstName</span>); <span style="color:#75715e">// &#34;Michael&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">lastName</span>);  <span style="color:#75715e">// &#34;Jackson&#34;
</span></code></pre></div><p><code>import</code> 命令接受一对大括号，其中指定从其他模块导入的变量名，<strong>大括号中的变量名，必须与被导入的模块对外接口的名称相同</strong></p><p>如果要为导入的变量重定义名字，可以用如下方式</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">firstName</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">name</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./example&#39;</span>
</code></pre></div><p><code>import</code> 输入的变量都是只读的，不允许在加载模块的脚本里修改。如果输入的变量是对象，可以修改它的属性，但是不建议这么做。</p><p>因为 <code>import</code> 是静态执行的，所以不能使用表达式、变量或者 <code>if</code> 结构。</p><h2 id="整体加载模块">整体加载模块</h2><p>可以使用如下方式将整个模块加载：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">name</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./example&#39;</span>
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;firstName: &#39;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">firstName</span>);
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;lastName: &#39;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">lastName</span>);
<span style="color:#75715e">// 不建议修改变量
</span><span style="color:#75715e"></span><span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">firstName</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Jack&#39;</span>;
</code></pre></div><h2 id="export-default-命令"><code>export default</code> 命令</h2><p><code>export default</code> 命令可以为模块指定默认输出，一个模块只能有一个默认输出</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// default.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">function</span> <span style="color:#66d9ef">default</span> () {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;default&#39;</span>)
}
</code></pre></div><p>当其他模块加载 <code>deafult.js</code> 时，<code>import</code> 命令可以为该模块指定任意名称，且此时 <code>import</code> 命令后不使用大括号。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">myDefault</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./default&#39;</span>
<span style="color:#75715e">// 同下面的引入方式等价
</span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> {<span style="color:#66d9ef">default</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">myDefault</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./default&#39;</span>
<span style="color:#a6e22e">myDefault</span>.<span style="color:#66d9ef">default</span>();
</code></pre></div><h2 id="export-和-import-同时使用"><code>export</code> 和 <code>import</code> 同时使用</h2><p>如果在一个模块中，先引入后输出同一个模块，可以采用如下方式：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">foo</span>, <span style="color:#a6e22e">bar</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;module&#39;</span>
<span style="color:#66d9ef">export</span> {<span style="color:#a6e22e">foo</span>, <span style="color:#a6e22e">bar</span>};
<span style="color:#75715e">// 简写如下
</span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> {<span style="color:#a6e22e">foo</span>, <span style="color:#a6e22e">bar</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;module&#39;</span>;
</code></pre></div><p>简写方式时，<code>foo</code> 和 <code>bar</code> 并没有被引入到当前模块，只是相当于对外转发了这两个接口，因此当前模块不能直接使用 <code>foo</code> 和 <code>bar</code>。</p><h2 id="模块的继承">模块的继承</h2><p>模块之间可以继承。假设有一个 <code>circleplus</code> 模块，继承了 <code>circle</code> 模块：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">export</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;circle&#39;</span>;
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.71</span>;
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">x</span>) {
    <span style="color:#66d9ef">return</span> Math.<span style="color:#a6e22e">exp</span>(<span style="color:#a6e22e">x</span>);
}
</code></pre></div><p><code>export *</code> 将 <code>circle</code> 模块中所有的方法和属性都输出。但是<code>export *</code> 会忽略 <code>circle</code> 模块的 <code>default</code> 方法。</p><p>加载上面的模块写法如下：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// 导入 export default 之外的变量和方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">math</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;circleplus&#39;</span>;
<span style="color:#75715e">// 导入 export default 的变量和方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">exp</span> <span style="color:#a6e22e">fro</span> <span style="color:#e6db74">&#39;circleplus&#39;</span>;
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">exp</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">e</span>));
</code></pre></div><h2 id="跨模块常量">跨模块常量</h2><p><code>const</code> 声明的常量只在当前代码块中有效，若要设置跨模块常量，可以使用如下方式：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// constants.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;

<span style="color:#75715e">// test1.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">constatns</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./constants&#39;</span>;

<span style="color:#75715e">// test2.js 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">import</span> {<span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./contants&#39;</span>
</code></pre></div><p>在常量比较多的情况下，可以建立一各专门的常量目录，将各个常量写在不同的文件中，然后将这些常量合并在 <code>index.js</code> 文件中。</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// constants/db.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">db</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">url</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;&#39;</span>,
    <span style="color:#a6e22e">username</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;&#39;</span>,
    <span style="color:#a6e22e">password</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;&#39;</span>
}

<span style="color:#75715e">// constants/user.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">users</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;root&#39;</span>, <span style="color:#e6db74">&#39;admin&#39;</span>]

<span style="color:#75715e">// index.js
</span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> {<span style="color:#a6e22e">db</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./db&#39;</span>
<span style="color:#66d9ef">export</span> {<span style="color:#a6e22e">users</span>} <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./user&#39;</span>
</code></pre></div></article></div><div class="card-action"><i class="material-icons">local_offer</i> <a class="tag" href="https://wzhongke.github.io//tags/javascript">#javascript</a>&nbsp;</div><div class="card-action"><div class="comments"><div id="disqus_thread"></div></div><script type="text/javascript">var disqus_shortname = 'wzhongke';

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></div></div><div class="pagination-single"><span class="pagination-item previous"><i class="material-icons">navigate_before</i> <a href="https://wzhongke.github.io/post/front/flex%E5%B8%83%E5%B1%80/" rel="prev">flex 布局</a> </span><span class="pagination-item next"><i class="material-icons">navigate_next</i> <a href="https://wzhongke.github.io/post/front/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript/" rel="next">你不知道的JavaScript读书笔记</a></span></div></div></section></div></section><footer class="page-footer"><div class="container"><div class="row"><div class="col l6 s12"><h5 class="white-text">World of Wang</h5><p class="grey-text text-lighten-4">Theme <a href="https://github.com/stkevintan/hugo-YAMT-theme" target="_blank">YAMT</a> designed by <a href="https://github.com/stkevintan" target="_blank">Kevin Tan</a> with ❤</p></div><div class="col l4 offset-l2 s12"><h5 class="white-text">My Friends</h5><ul><li><a class="grey-text text-lighten-3" href="https://frantic1048.logdown.com/" target="_blank">Frantic1048</a></li></ul></div></div></div><div class="footer-copyright"><div class="container">Copyright@Kevin Tan</div></div></footer></main><script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script type="text/javascript" src="//dlweb.sogoucdn.com/common/lib/jquery/jquery-1.11.0.min.js"></script><script type="text/javascript" src="//cdn.bootcss.com/lunr.js/2.1.2/lunr.min.js"></script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']]
      }
    });</script><script type="text/javascript" src="https://wzhongke.github.io//js/materialize.min.js"></script><script type="text/javascript" src="https://wzhongke.github.io//js/index-1c463e212c.js"></script><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-9350854994277981",
        enable_page_level_ads: true
    });</script></body></html>